#include <bits/stdc++.h>
using namespace std;
int field[125][125];
int sum[125][125];
int n = 0, a = 0;
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            cin >> field[i][k];
            sum[i][k] = sum[i - 1][k] + sum[i][k - 1] - sum[i - 1][k - 1] + field[i][k];
        }
    }
}
// 查询：
void find()
{
    int max_num = -1000;
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            for (int g = 1; g <= n; g++)
            {
                for (int h = 1; h <= n; h++)
                {
                    if(g>=i&&h>=k)
                    {
                       int ans=sum[g][h]-sum[i-1][h]-sum[g][k-1]+sum[x1-1][y1-1]
                         //i是x1,k是y1,g是x2,h是y2 
                        //ans=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]

                    }
                }
            }
        }
    }
}
/*
计算：
定义一个二维前缀和数组 s，其中 s[i][j] 表示从左上角 (1,1) 开始到右下角 (i,j) 这一片矩形中元素值的和。这时，我们在计算前缀和的时候就不像一维一样简洁了，需要考虑到区间重复问题，我先给出二维前缀和的计算公式：

s [ i ] [ j ] = s [ i − 1 ] [ j ] + s [ i ] [ j − 1 ] − s [ i − 1 ] [ j − 1 ] + a [ i ] [ j ]
s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]
s[i][j]=s[i−1][j]+s[i][j−1]−s[i−1][j−1]+a[i][j]

不要着急，我们一步步来解析，假设现在求的是 s[3][3]，其运算公式如下：

s [ 3 ] [ 3 ] = s [ 2 ] [ 3 ] + s [ 3 ] [ 2 ] − s [ 2 ] [ 2 ] + a [ 3 ] [ 3 ] s[3][3]=s[2][3]+s[3][2]-s[2][2]+a[3][3]s[3][3]=s[2][3]+s[3][2]−s[2][2]+a[3][3]
查询：
再来看查询的情况，查询的计算公式其实和上面相反，运算的时候同样会遇到重复区域，只不过这里是多减了一个重复区域，需要运算的时候加上。假设左上角坐标为 (x1,y1)，右下角为 (x2,y2)，可以得到如下公式：

a n s = s [ x 2 ] [ y 2 ] − s [ x 1 − 1 ] [ y 2 ] − s [ x 2 ] [ y 1 − 1 ] + s [ x 1 − 1 ] [ y 1 − 1 ]
ans=s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]
ans=s[x2][y2]−s[x1−1][y2]−s[x2][y1−1]+s[x1−1][y1−1]

我们来看开头举的那个例子，左上角坐标为 (2,2)，右下角坐标为 (3,3)，所以运算公式如下：

a n s = s [ 3 ] [ 3 ] − s [ 1 ] [ 3 ] − s [ 3 ] [ 1 ] + s [ 1 ] [ 1 ] ans=s[3][3]-s[1][3]-s[3][1]+s[1][1]ans=s[3][3]−s[1][3]−s[3][1]+s[1][1]

*/