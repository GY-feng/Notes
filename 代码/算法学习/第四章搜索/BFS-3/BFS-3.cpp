#include<bits/stdc++.h>
using namespace std;
/*
BFS算法与A*算法：
BFS是一种“盲目”的搜索技术，过程中并不理会目标在哪里
A*属于一种“启发式搜索算法”简单而言，A*是BFS+贪心法

程序如何知道向某个方向走最快？引入曼哈顿距离（两个点在坐标系上的实际距离（先上后下那种）
从起点开始一圈，附近的点找到其曼哈顿距离，走曼哈顿距离更小的那样一个方向
A*：
用一个评估函数f（x）对情况进行评估，得到最好的状态，从这个状态继续搜索，找到最好的目标
f(x)=g(x)+h(x)
g(X)表示从初始状态到x的实际代价，不体现x和终点的实际关系
h(X)表示x到终点的最优路径的评估（启发函数）h（x）决定了算法的优劣,h(x)不能漏掉最优解！

八数码中,曼哈顿距离就是h(x).就是当前每一个数据到目标每一个数据的曼哈顿距离之和

双向广搜：
    BFS增强版
    BFS想象成：在起点丢一块石头激起千层浪直到碰到终点，那么双向广搜就是在起点、终点同时做BFS
        两个波浪在某个位置相遇，就是最优路径了，这样比BFS的空间少很多，更有效
    应用地点：知道起点和终点，并且正向和逆向都能进行搜索
*/
int main()
{

}