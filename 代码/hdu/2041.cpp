#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int n;
int dp[45];
void solve(int n)
{
    memset(dp, 0, sizeof(dp)); // dp置为0
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 1;
    // 枚举楼梯数，在第i阶楼梯有dp[i]种走法
    for (int i = 3; i <= n; i++)
    {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
}
int main()
{
    cin >> n;
    int tmp;
    for (int i = 0; i < n; i++)
    {
        cin >> tmp;
        solve(tmp);
        cout << dp[tmp] << endl;
    }
}
/*
void PWM_init()
{
    /*
    1,RCC 时钟TIM喝GPIO打开
    2,时钟单元
    3，配置输出比较单元
    4，配置GPIO，复用推挽输出
    5，运行控制，启动计数器
    配置输出比较模块
    一个对应一个单元
    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);

    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);默认值

    void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);配置强制输出模式，运行中输出波形，少用

    配置预装功能，影子寄存器，在更新事件生效，少用
    void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
配置快速使能，少用
void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
少用：
void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
单独设置输出比较的极性的，带N：高级定时器里互补通道的配置，也可以在初始化调用
void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
单独更改输出比较模式：
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
单独更改CCR值的函数（可以改占空比），重要
void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);
void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);
void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);
void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);
补充：仅高级定时器输出PWM要调用，使能主输出，否则不会输出
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);

*/
/*
    //1开启时钟
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
  //2，选择时基单元的时钟
  TIM_InternalClockConfig(TIM2);//选择内部时钟（也是系统默认）
  //3，配置时基单元，ARR，RSC，CNT等
  TIM_TimeBaseInitTypeDef i;
  i.TIM_ClockDivision=TIM_CKD_DIV1;//指定时钟分频，滤波器用
  i.TIM_CounterMode=TIM_CounterMode_Up;//计数器模式向上等

  //定时频率=72M/(PSC+1)/(ARR+1),定时1s=>定时频率为1
  //不要超65535
  i.TIM_Period=100-1;//ARR
  i.TIM_Prescaler=720-1;//PSC
  i.TIM_RepetitionCounter=0;//重复计数器，高级才有
  TIM_TimeBaseInit(TIM2,&i);


  //初始化输出比较单元
  TIM_OCInitTypeDef t;
  TIM_OCStructInit(&t);//赋初始值，懒得把所有成员给初始值
  t.TIM_OCMode=TIM_OCMode_PWM1;
    t.TIM_OCPolarity=TIM_OCPolarity_High;
    t.TIM_OutputState=TIM_OutputNState_Enable;
    t.TIM_Pulse=0;//脉冲，设置CCR寄存器值的
TIM_OC1Init(TIM2,&t);

//初始化输出PWM的GPIO：
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//打开时钟

  GPIO_InitTypeDef GPIO_InitStructure;//配置端口模式
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//复用推挽输出，普通开漏、推挽输出，引脚的控制权来自于输出数据寄存器的。要让定时器来控制引脚，那么就要采用复用模式
  GPIO_InitStructure.GPIO_Pin =GPIO_Pin_0;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  //6，运行控制，使能一下计数器，定时器使能后，就会开始计数了，计数器更新后，触发中断
  TIM_Cmd(TIM2,ENABLE);
}
*/
[0:1.380, 0:6.340] 欢迎回来，那接下来我们就来写一下编码及接口测速的代码。
    [0:6.340,
        0:12.440] 首先还是接线部分，我们打开接线图，打开6 -
    8的图片看一下。
    [0:13.920,
        0:17.680] 这个截线和之前外部中断那一截的类似哈。
    [0:17.700,
        0:27.120] 我们把旋转编码器插在左边，VCC和进D接上电源正负极下面的A项输出，我们接到PA60件。
    [0:27.840,
        0:30.620] 地下输出接到PA7硬件。
    [0:30.620,
        0:43.040] 这里PA6和PA7两个引角可以交换一下啊，A项接PA6 B项接PA7，或者A项接PA7 B项接PA6都是可以的哈，就是正转和反转的极性不一样而已。
    [0:43.040,
        0:47.340] 但是PA6和PA7这两个引角不能随便更换。
    [0:47.340,
        0:49.320] 我们看一下引角定义。
    [0:51.640,
        1:1.700] PA6和PA7是TM3的通道1和通道2。我们计划用TM3接编码器，所以需要接待PA6和PA7这两个阴角。
    [1:1.700,
        1:9.120] 其他定时器的话也都需要参考这个表哈，接在对应TM的CH1和CH2这两个引角的位置。
    [1:9.340,
        1:14.240] 所以这里编码器的AB项我们接的是PA6和PA7。
    [1:14.240,
        1:15.940] 这是接线图。
    [1:16.260,
        1:19.340] 然后看一下面包板来接下线啊。
    [1:19.340,
        1:21.880] 首先拿出旋转编码器模块。
    [1:21.880,
        1:24.480] 插在面包板左边合适的位置啊。
    [1:27.200,
        1:30.520] 然后用跳线接一下上面的电源部分。
    [1:30.520,
        1:32.600] VCC接电源阵。
    [1:35.640,
        1:37.800] 间地接电源负。
    [1:39.420,
        1:41.620] 最后再拿2根飞线啊。
    [1:41.660,
        1:44.180] A项接在PA6。
    [1:46.400,
        1:48.760] B项，接待PA。
    [1:53.220,
        1:55.140] 这样接线就完成了。
    [1:57.000,
        2:0.360] 之后，我们回到工程文件夹，开始写代码。
    [2:1.300,
        2:5.900] 我们从这个定时器定时中断的代码基础上写复制一下。
    [2:6.320,
        2:7.920] 改个名字。
    [2:8.560,
        2:10.080] 6 -
    8。
    [2:10.220,
        2:14.320] 编码器接口测速打开工程。
    [2:23.700,
        2:26.720] 这里原来这些代码先注释掉哈。
    [2:28.080,
        2:31.580] 电池中断这部分先也注释掉。
    [2:31.580,
        2:33.480] 我们等会儿还会使用哈。
    [2:33.480,
        2:35.140] 先编译一下。
    [2:46.640,
        2:48.040] 没问题。
    [2:48.040,
        2:50.740] 好，我们来看一下编码器接口的代码。
    [2:50.740,
        3:0.480] 先新建一个模块，在hardware处右键添加新文键，选择C文件编码器接口，我们的名字还叫encode。
    [3:0.480,
        3:3.340] 存放路径加上反斜杠。它的外。
    [3:3.560,
        3:4.760] 爱的。
    [3:4.760,
        3:7.100] 然后继续添加新文件。
    [3:7.100,
        3:12.620] 选择H文件叫encode存放路径加上反斜杠Hardy。
    [3:13.220,
        3:16.300] 接下来头文件的固定部分快速写上。
    [3:19.720,
        3:23.280] C文件，这里加一个STM32的头文件。
    [3:25.000,
        3:26.880] 这样模块就建好了。
    [3:27.120,
        3:32.280] 然后在这里我们写个初始化函数yco。
    [3:32.280,
        3:33.620] Elite.
    [3:33.620,
                           3:34.720] Wider.
    [3:34.720,
        3:40.200] 在这里进行编码器接口的初始化，还是先看一下结构图，熟悉一下流程啊。
    [3:40.200,
        3:50.280] 第一步RCC开启时钟，开启GP和定时器的时钟。第二步配置GP，这里需要把PA6和PA7配置成输入模式啊。
    [3:50.320,
        3:55.960] 第三步，配置实际单元，这里预分频器，我们一般选择不分屏。
    [3:55.960,
        4:1.360] 自动重装一般给最大6535，只需要个CT执行技术就行了。
    [4:1.360,
        4:4.100] 第4步，配置书捕获单元。
    [4:4.100,
        4:8.700] 不过这里书补和单元只有滤波器和极性这两个参数有用。
    [4:8.700,
        4:11.900] 后面的参数没有用到哈，与编码器无关。
    [4:11.900,
        4:17.520] 第5步，配置编码器接口模式，这个直接调用一个库函数就可以了。
    [4:17.520,
        4:27.040] 最后调用TMCMD启动定时器就完事了。电路初始化完成之后，CT就会随着编码器旋转而自增自减。
    [4:27.040,
        4:31.900] 如果想要测量编码器的位置，那直接读出CD的值就行了。
    [4:31.900,
        4:40.740] 如果想测量编码器的速度和方向，那就需要每隔一段固定的闸门时间取出一次CT，然后再把CD清零。
    [4:40.740,
        4:43.140] 这样就是测评法测量速度了。
    [4:43.140,
        4:46.100] 那流程看完，我们来看一下库函数。
    [4:46.120,
        4:48.620] 打开TM点的文件。
    [4:49.040,
        4:51.180] 在这里找一下括函数啊。
    [4:51.180,
        4:55.800] 本小节我们需要新学习的扩展数比较少，只有这一个。
    [4:56.100,
        5:9.680] Tmco interface config定时器编码器接口配置第一个参数选择定时器，第二个参数选择编码器模式，然后后面两个参数分别选择通道1和通道2的电瓶极性。
    [5:9.680,
        5:14.820] 这是配置编码器接口的函数，其他函数啊，我们就不需要再了解了。
    [5:14.820,
        5:17.280] 那回到这里，我们开始写代码哈。
    [5:17.280,
        5:23.220] 首先前面几步和之前的代码基本一样，我们还是到之前的代码复制一下。
    [5:23.280,
        5:25.860] 我们打开这个书补货的代码。
    [5:32.160,
        5:34.140] 然后从这里。
    [5:36.160,
        5:38.620] 到这里复制下来。
    [5:40.880,
        5:43.980] 在这个inco elite里面粘贴。
    [5:44.700,
        5:46.460] 然后主行看一下。
    [5:46.480,
        5:55.280] 第一步，开启时钟TM3GPLA没问题。第二步GP初始化，我们使用的是PA6和PA7。
    [5:55.280,
        5:58.600] 所以GPLPIN。这里我们加个或。
    [5:59.220,
        6:1.680] GPP7。
    [6:1.860,
        6:8.140] 下面初始化GP，这样就是把PA6和PA7配置成上拉输入模式。
    [6:8.200,
        6:20.340] 另外这里这个GPL模式可以选择上拉、下拉或者浮空，上拉和下拉如何选择呢？我们一般可以看一下接待这个引角的外部模块输出的默认点评。
    [6:20.340,
        6:26.880] 如果外部模块空闲，默认输出高电平，我们就选择上来输入，默认输入高电平。
    [6:26.880,
        6:33.160] 如果外部模块默认输出低电频，我们配置下达输入默认输入低电平。
    [6:33.160,
        6:40.260] 和外部模块保持默认状态一致哈，防止默认电瓶打架，这是上拉和下拉的选择原则哈。
    [6:40.260,
        6:46.360] 不过一般来说，默认高电平是一个习惯的状态，所以一般上拉输入用的比较多。
    [6:46.360,
        6:54.560] 然后如果你不确定外部模块输出的默认状态，或者外部信号输出功率非常小，这时就尽量选择浮控输入哈。
    [6:54.560,
        6:58.960] 浮空输入没有上拉电阻和下拉电阻去影响外部信号。
    [6:58.960,
        7:9.960] 但是缺点就是当引脚悬空时，没有默认的电频了，输入就会受噪声干扰，来回不断的跳变，这就是3种输入模式的选择。原子哈再大概讲一下。
    [7:10.100,
        7:23.280] 然后继续往下看定时器内部时钟配置，这一行就不需要了，因为编码器接口会托管时钟，编码器接口就是一个带方向控制的外部时钟啊，所以这个内部时钟就没有用了。
    [7:23.400,
        7:25.820] 接下来是实际单元配置。
    [7:25.820,
        7:32.540] 计数器模式这个参数目前也是没有作用的哈，因为技术方向也是被编码器接口托管的。
    [7:32.540,
        7:38.120] 自动重装值目前还是给6536 -
    1，也就是满量程技术啊。
    [7:38.120,
        7:42.160] 这样记住的范围是最大的，而且方便换算为负数。
    [7:42.300,
        7:45.580] 预分娩器这里改成1 -
    1。
    [7:45.580,
        7:48.220] 遇分平给0，就是不分平啊。
    [7:48.220,
        7:53.040] 编码器的时钟直接驱动计数器。最后初始化TM3。
    [7:53.040,
        7:55.460] 这就是实际单元部分的配置。
    [7:55.460,
        8:2.080] 接着继续往下看，下一步就是输入补货单元的配置，这里看一下PPT啊。
    [8:2.080,
        8:19.000] 可以看出，输5和单元并没有全部使用到编码及接口，只使用了通道1和通道2的滤波器和即兴选择，所以我们只需要配置这两部分的参数即可，那在代码里就是后面这两个参数与编码器无关啊，我们可以直接删掉。
    [8:19.020,
        8:22.240] 或者你留着也行，只是他们目前没有作用。
    [8:22.240,
        8:42.580] 那删掉之后，目前结构体的配置是不完整的，为了防止结构体中出现不确定值可能会造成的问题啊，我们最好用structure引给结构体赋一个初始值，加个structure elite也是提醒一下我们哈，结构体并没有配置完整，那在定义结构体变量之后，我们来一个TM。
    [8:42.620,
        8:46.580] IC structure结构体初始化。
    [8:46.580,
        8:50.540] 把这个结构体的地址传进去，附一个初始值哈。
    [8:50.540,
        8:52.280] 转到定义看一下。
    [8:54.400,
        8:57.160] 这些就是它默认给的初始值。
    [8:57.160,
        9:17.700] 然后回到这里，初始值负号之后我们再指定通道为1，滤波器为0XF，电瓶极性为上升眼上下节。我们说过这里的上层沿并不代表上层沿有效哈，因为编码器接口始终都是上层沿下降沿都有效的。这里的上层沿参数代表的是高低电频急性不反转。
    [9:17.700,
        9:27.620] 也就是我们PPT这里演示的TI1T2是否反向，对应通道给上3眼就是不反向，给下降沿就是反向这个意思。
    [9:28.340,
        9:35.220] 其实这里的这个极性参数啊，等会儿我们配置编码器接口的时候，也有属于重复配置的。
    [9:35.220,
        9:46.480] 这里这个其实也可以删掉，等会儿对比一下之后再删哈，那这里参数配置好了，最后传给ice，把这些参数写到通道1，然后还有通道2。
    [9:46.480,
        9:49.000] 我们复制一下这下面一部分。
    [9:49.380,
        9:54.380] 把通道号改成千楼2，另外两个参数可以在这里指定哈。
    [9:54.380,
        9:59.680] 指定好之后，再调用ice，把下面这些参数写入到通道2。
    [9:59.780,
        10:8.680] 整理一下这一块代码的逻辑啊，就是首先定义结构体变量，然后structure edit给结构体赋一个初始值。
    [10:8.680,
        10:20.100] 在部分修改我们想要的参数，调用ice配置一遍电路这个结构体变量的配置哈，调用ice函数之后就写入到硬件的计统器了。
    [10:20.100,
        10:31.060] 所以之后这个结构体我们可以换个值继续使用，不需要重新定义新的结构体了哈，那到这里两个通道的滤波器和极性就都配置好了。
    [10:31.060,
        10:32.800] 这一步也就完成了。
    [10:32.800,
        10:36.000] 接下来，下一步配置编码器接口。
    [10:36.000,
        10:38.980] 这里我们只需要调用一个函数就行了。
    [10:38.980,
        10:45.600] 到TM点距离，复制这个TM control interface config放到这里。
    [10:45.980,
        10:52.180] 参数第一个TMX给TM3，剩下的转到第一看一下哈。
    [10:53.800,
        10:58.720] 第二个编码器模式可以选择下面三个参数之一。
    [10:58.720,
        11:9.000] 第一个TI1就是仅在TI1技术，第二个TI2就是仅在TI2技术，第三个TI12就是TI1和TI2都技术。
    [11:9.620,
        11:12.700] 对应我们PPT这个位置的三个模式。
    [11:12.700,
        11:18.020] 那我们一般使用TR1和TR2都计数哈，所以复制第三个参数。
    [11:18.560,
        11:19.900] 放到这里。
    [11:20.980,
        11:23.320] 接着继续转到定义。
    [11:23.320,
        11:24.340] 看一下。
    [11:24.740,
        11:29.420] 后两个参数就是I1的极性和S2的极限了。
    [11:29.420,
        11:32.820] 参数列表一样哈，都是following和reason。
    [11:32.820,
        11:38.000] 选择reason就是这个通道不反向，选择就是这个通道反向。
    [11:38.040,
        11:40.780] 这个可以根据实际情况来配置哈。
    [11:40.780,
        11:43.760] 我们目前可以先选择复制。
    [11:45.140,
        11:46.560] 放到这里。
    [11:46.920,
        11:50.020] 然后最后一个参数再给一次。
    [11:50.600,
        11:52.520] 这样参数就配置好了。
    [11:52.640,
        11:58.980] 然后大家可以注意到哈，这里后两个参数和上面这里的两个参数是一样的。
    [11:58.980,
        12:1.680] 实际的效果呢，确实就是一样的。
    [12:1.680,
        12:7.780] 这两个地方的参数啊，其实都配置的是同一个集中器，属于重复配置的哈。
    [12:7.780,
        12:10.980] 厚被子的参数会覆盖前面的参数。
    [12:10.980,
        12:17.260] 所以我们可以把这前面这个极星的参数也删掉哈，只使用后面这个函数来配置极星。
    [12:17.260,
        12:24.020] 不过要注意，这时一定要保证这个code函数位于ice函数的下面。
    [12:24.020,
        12:29.300] 否则的话就是ice覆盖inco函数的配置，这个注意一下。
    [12:29.300,
        12:34.340] 那现在看这个ice参数啊，就只剩一个滤波器还有用哈。
    [12:34.680,
        12:38.040] 好，到这里我们整个电路就配置完成了。
    [12:38.040,
        12:42.460] 最后我们再调用一个TMCMD。
    [12:43.000,
        12:44.660] TM3。
    [12:45.780,
        12:47.380] 开启定时器。
    [12:47.380,
        12:49.680] 这样初始化配置就结束了。
    [12:50.660,
        12:56.420] 调用一下这个CODE1函数编码器旋转就能控制CT自增自减了。
    [12:56.420,
        12:59.140] 那我们下面再写一个get函数啊。
    [12:59.140,
        13:1.360] UNIT16 -
    T。
    [13:1.640,
        13:4.000] Get.
    [13:4.120,
                         13:5.400] 我的。
    [13:5.400,
                         13:9.680] 在这里面，我们暂时先直接返回CT的值看看。
    [13:9.680,
                         13:11.700] 直接return。
    [13:11.840,
                         13:13.440] TM.
    [13:13.460,
                                          13:15.140] Get counter.
    [13:15.140,
                                                                    13:16.460] TM3。
    [13:16.780,
                                                                    13:18.540] 这样来测试一下。
    [13:18.540,
                                                                    13:21.740] 那我们把这两个函数都放到头文件声明一下。
    [13:24.840,
                                                                    13:26.140] 编译。
    [13:28.780,
                                                                    13:30.180] 没问题啊。
    [13:30.180,
                                                                    13:32.700] 然后回到点C测试一下。
    [13:32.700,
                                                                    13:35.720] 先include一下，Include点去。
    [13:35.780,
                                                                    13:37.760] 然后main函数进来。
    [13:37.820,
                                                                    13:40.700] 先code elite初始化。
    [13:41.180,
                                                                    13:46.540] 目前呢，我们就直接在主循环里不断刷新CD的值就行了。
    [13:46.540,
                                                                    13:56.360] 这个显示字符串改成CT，然后主循环解除注释，不断修number，一行5列显示code get.
    [13:56.360,
        14:2.500] 目前include get就是直接返回身T的值哈，长度为5，这样来试一下。
    [14:2.500,
        14:3.740] 编译。
    [14:5.500,
        14:7.680] 没问题，下载。
    [14:8.160,
        14:9.380] 看一下。
    [14:9.860,
        14:14.380] 目前显示CT是0，我们向右转一下编码器。
    [14:14.380,
        14:16.560] 可以看到值变成4了。
    [14:16.560,
        14:28.580] 我们这个编码器是有这个段落感的啊，每转一格，它输出的波形其实是这样的，A向产生一个低电平脉冲，B向产生一个相位差90°的脉冲。
    [14:28.580,
        14:32.100] 提前还是之后，取决于正转还是反转。
    [14:32.100,
        14:47.900] 如果连续转动啊，就和我们PPT的波形是一样的了，那可以看出现在编码器转动一格，AB向各出现了一个下降沿和上升眼，所以G次总共加了4次，但如果你是电机的编码线，那就不会有这个段落感了。
    [14:47.900,
        14:51.560] 然后我们继续往右转，CT就继续指针。
    [14:51.560,
        14:55.560] 往左转呢，身体就自检这个现象没问题啊。
    [14:55.560,
        15:0.680] 然后接下来我们来实验一下，向左转到0之后是什么情况呢？
    [15:1.160,
        15:2.820] 我们转到0。
    [15:3.620,
        15:13.440] 再往左转，转慢点可以看到0，再自减，计数器反向溢出，回到自动重装值6535，然后继续往下减。
    [15:13.740,
        15:17.800] 这就是目前我们使用U16 -
    T数据的现象。
    [15:17.800,
        15:20.980] 那如果我们想要0之后变为 -
    1。
    [15:20.980,
        15:27.720] 就直接把UT16 -
    T类型强制转换成T16 - T就行了，我们试一下。 [15:27.760,
                                                15:37.300] 你可以直接把修number改成修3的number哈，这样就行，也是进行一个类型旋转，那我们还是在这里get的时候就转换一下吧。 [15:37.300,
                                                                                                                                                                           15:41.400] 这里函数的返回值直接换成T16 -
    T。
    [15:41.520,
        15:44.380] 然后函数声明也别忘了改一下。
    [15:44.380,
        15:47.920] 在主循环里改成修3NUMBER。
    [15:47.960,
        15:51.240] 这样就能显示负数了，我们试一下。
    [15:54.480,
        15:55.780] 下载。
    [15:56.060,
        15:57.320] 看一下。
    [15:57.320,
        15:59.080] 现在是0。
    [15:59.520,
        16:7.340] 向右转竖直自增，向左转竖直自减，0之后变成负数继续自减哈。
    [16:7.900,
        16:12.620] 这个是借用不满的特性，快速完成复数转换的小技巧啊。
    [16:12.640,
        16:15.600] 之后我们再来研究一下急性的问题。
    [16:15.660,
        16:19.000] 目前向右转是增，向左转是减。
    [16:19.040,
        16:23.760] 如果这个方向和你想要的不一致的话，可以修改一下即兴。
    [16:23.760,
        16:26.320] 在硬件上面我们可以这样。
    [16:26.320,
        16:28.860] 把AB项两根线换一下。
    [16:30.680,
        16:33.160] 这样增减方向就可以反过来了。
    [16:33.160,
        16:34.320] 试一下。
    [16:34.420,
        16:36.660] 现在向右是减。
    [16:36.660,
        16:38.420] 向左是针。
    [16:39.420,
        16:44.640] 那在软件层面呢，我们可以修改这里的两个输入通道的即兴。
    [16:44.640,
        16:48.440] 把任意一个急性反转一下方向就会反过来。
    [16:48.440,
        16:57.620] 如果两个极性都反转，那极性还是保持不变哈，所以我们目前想改变极性的话，可以把第一个这里的reason改成。
    [16:58.520,
        17:0.020] 试下看看。
    [17:2.280,
        17:3.600] 下载。
    [17:4.100,
        17:6.780] 现在吉星就是又反转过来了。
    [17:6.780,
        17:9.520] 向右是增，向左是减。
    [17:9.540,
        17:11.560] 这就是急性的问题。
    [17:11.580,
        17:19.160] 目前我们这个代码是编码器测量位置，如果需要测量位置的话，就这样直接get CR就行了。
    [17:19.540,
        17:21.400] 那我们继续研究。
    [17:21.400,
        17:23.380] 把这个线先回来。
    [17:26.940,
        17:29.300] 程序这里即兴也改回来。
    [17:30.080,
        17:33.140] 如果我们想用这个编码器来测速的话。
    [17:33.140,
        17:38.220] 就可以在固定的闸门时间读一次CT，然后把CT清零。
    [17:38.220,
        17:42.800] 我们修改一下这个get函数，要求读完后清零CT。
    [17:42.800,
        17:46.960] 所以我们要定一个临时变量INT16 -
    7。
    [17:47.240,
        17:48.520] Temp.
    [17:48.960,
        17:50.360] 然后呢？
    [17:50.380,
        17:54.860] Temp = TM get counter获取CT。
                          [17:54.860,
                              17:56.140] 之后。
                          [17:56.140,
                              17:58.480] TM set counter.
                          [17:59.680,
                                                           18:1.280] TM3。
                          [18:1.620,
                                                           18:4.300] 0给3T清0。
                          [18:4.300,
                                                           18:6.420] 最后return ta.
                          [18:6.420,
                                                                                      18:14.560] 这就是读取圣，然后把CT清零的逻辑，因为要先读取后清零，所以需要用temp缓存一下哈。
                          [18:14.600,
                                                                                      18:16.180] 我们来试一下。
                          [18:16.180,
                                                                                      18:19.740] 在主循环里，每隔一段时间get一次。
                          [18:19.760,
                                                                                      18:23.240] 所以下面可以给一个底内1000ms。
                          [18:24.940,
                                                                                      18:33.320] 因为我们人手转比较慢哈，所以咱们时间就给1秒，如果你是电击飞速旋转的话，咱们时间就可以给短点哈。
                          [18:33.320,
                                                                                      18:37.680] 这样可以提高速度刷新的频率，而且防止计数器溢出哈。
                          [18:37.860,
                                                                                      18:39.360] 我们来试一下。
                          [18:42.540,
                                                                                      18:43.940] 下载。
                          [18:43.940,
                                                                                      18:45.040] 看一下。
                          [18:45.320,
                                                                                      18:50.440] 目前CT的值就代表速度，单位是脉冲个数每秒。
                          [18:50.440,
                                                                                      18:52.360] 我们向右慢速转。
                          [18:52.480,
                                                                                      18:55.440] 速度是正数比较小哈。
                          [18:55.640,
                                                                                      18:58.160] 快速转正数比较大。
                          [18:59.180,
                                                                                      19:5.100] 向左慢速转速度负数比较小，快速转负数比较大。
                          [19:5.360,
                                                                                      19:9.860] 好，这就是我们这个用旋钮模拟编码器测速的程序现象。
                          [19:10.060,
                                                                                      19:19.520] 当然，我们目前只是用这个旋钮模拟的测速啊，如果你有编码电机的话，可以实际接电机的编码器试试看，现象都是一样的哈。
                          [19:19.520,
                                                                                      19:25.980] 不过要注意把这个咱们时间弄短点，防止技术溢出，那程序现象到现在就完成了。
                          [19:25.980,
                                                                                      19:29.780] 不过目前我们是直接通过delay实现的。闸门时间。
                          [19:29.780,
                                                                                      19:41.080] 如果你主程序没有其他东西的话，可以这样来做，但是如果有其他东西的话，最好就不要在主循环加入过长的底内哈，这样会阻塞主循环的执行。
                          [19:41.080,
                                                                                      19:47.440] 那比较好的方法就是用这里留了这么久的定时中断了，我们解除注释。
                          [19:47.540,
                                                                                      19:50.700] 上面timer elite也解除注释啊。
                          [19:50.700,
                                                                                      19:58.260] 这里定时中断目前是每隔1秒执行一次，你可以修改定时中断的时间哈，来调整咱们时间。
                          [19:58.360,
                                                                                      20:4.120] 之后我们可以在前面定义一个全局变量T16杠，T是B的。
                          [20:4.800,
                                                                                      20:8.460] 然后在电池中断里执行10B的。
                          [20:8.460,
                                                                                      20:9.720] 等于。
                          [20:9.720,
                                                                                      20:10.940] Encoder.
                          [20:11.120,
                                                                                                            20:12.340] Get.
                          [20:13.400,
                              20:21.160] 每隔一秒读取一下速度，存在10B的变量里，然后走循环，就可以快速刷新显示10B的了。
                          [20:21.520,
                              20:25.760] Delay可以删掉，这样就不会阻塞主循环就行了。
                          [20:25.840,
                              20:29.440] 然后前面的字符串我们也改成B的哈。
                          [20:29.440,
                              20:37.720] 下面显示数字的位置，往后挪两格，改到7列，这样我们整个程序就完成了。我们试一下编译。
                          [20:40.420,
                              20:41.700] 下载。
                          [20:42.000,
                              20:43.260] 看一下。
                          [20:44.300,
                              20:46.800] 向右旋转正的速度。
                          [20:47.140,
                              20:49.560] 向左旋转负的速度。
                          [20:50.200,
                              20:52.360] 停止速度为0。
                          [20:53.000,
                              20:55.780] 这是我们最终程序的现象哈。
                          [20:56.220,
                              21:2.020] 好，到这里我们这个编码机接口测速的代码就写完了，我们下节再见。
