T=int(input())
def count(n,m,k):
    l=k # 左节点
    r=k # 右节点
    ans=1 #总结点的数量
    res=1 #记录每一层节点的数量
    while r*m+1<=n: # 子节点的最右端小于n，说明还没有到尽头
        res*=m # 计算这一层所有子节点的数量
        ans+=res
        l=l*m-m+2 # 下一层的左节点
        r=r*m+1 #下一层的右节点
        pass
    l=l*m-m+2 #最后一层的左端点
    ans+=max(0,n-l+1) #算出这一层的节点的数量
    return ans
    pass
for i in range(T):
    n,m,k=map(int,input().split())
    print(count(n,m,k))
"""
l = l * m - m + 2，
假设当前是第 k 个节点，它的子节点范围为 [k * m - m + 2, k * m + 1]。
左端点 l 表示当前层第一个子节点的编号，因此可以用 l = l * m - m + 2 来更新 l，
即乘以 m 表示跳到下一层的第一个子节点，然后减去 m 再加 2 是因为在当前层，第一个子节点编号比当前节点编号大 m - 1，
因此要加上 2 以得到下一层第一个子节点的编号。

对于 r = r * m + 1，同样假设当前是第 k 个节点，它的子节点范围为 [k * m - m + 2, k * m + 1]。右端点 r 表示当前层最后一个子节点的编号，因此可以用 r = r * m + 1 来更新 r，即乘以 m 表示跳到下一层的最后一个子节点，然后加上 1 是因为在下一层，最后一个子节点编号比当前节点编号大 m，因此要加上 1 以得到下一层最后一个子节点的编号。
"""
