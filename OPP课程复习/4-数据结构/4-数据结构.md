# ADT抽象数据：

ADT包含：
    1，数据的存储
    2，数据的操作
    3，与操作相关的错误条件

# 栈
![img.png](img.png)

# 队列
![img_22.png](img_22.png)

![img_23.png](img_23.png)

![img_24.png](img_24.png)
# 链表 linked list

数组和队列的缺点：

    除了在前面插入外，任何其他位置的插入都是昂贵的。
    动态数组的长度可能比空间的数量更长。
    操作的平摊边界在实时系统中可能不可接受。

链表提供了一个有用的替代方案：

    插入更容易，因为我们追踪前端和（通常）末尾。
    长度是成比例的。
    最坏情况的时间复杂度为 O(n)。

## 单链表结构：
每一个data由一个元素和指针构成
![img_1.png](img_1.png)
```python
class Node:
    def __init__(self,data):
        self.data=data
        self.next=None #初始化为null

class LinkList:
    def __init__(self):
        self.head=None

    def add_first(self,data):
        new_node = Node(data)
        new_node.next=self.head
        self.head=new_node
    def remove_first(self):
        if self.head:
            remove_data=self.head.data
            self.head=self.head.next
            return remove_data
        else:
            return None
    def add_list(self,data):
        new_node=Node(data)
        if not self.head: #如果没有东西的话，那就加上咯
            self.head=new_node
        else:
            current=self.head
            while current.next:
                current=current.next
            current.next=new_node

llist=LinkList()
llist.head=Node(1)
second=Node(2)
third=Node(3)

llist.head.next=second

second.next=third
```

在单向链表中从尾部移除是低效的：

    • 没有一种常数时间的方法来更新尾部指向前一个节点。
    • 我们需要知道末尾前面的元素，这并不容易做到。

作为链表的堆栈：

    我们可以使用单向链表来实现堆栈。
    栈顶元素存储在链表的第一个节点。
    使用的空间为 O(n)，每个堆栈 ADT 操作的时间复杂度为 O(1)。
![img_2.png](img_2.png)

作为链表的队列：

    我们可以使用单向链表来实现队列。
    前端元素存储在第一个节点。
    后端元素存储在最后一个节点。
    使用的空间为 O(n)，每个队列 ADT 操作的时间复杂度为 O(1)。
![img_3.png](img_3.png)
![img_4.png](img_4.png)

## 双链表结构 double linked list

双向链表的构成：
前指针，数据，后指针
![img_5.png](img_5.png)
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


class DoublyLinkedList:
    def __init__(self):
        # 通常使用头部指针 head 来表示链表的起始节点，而尾部指针 tail 表示链表的最后一个节点。
        self.head = None
        self.tail = None

    def add_last(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def remove_at(self, position):
        if position < 0:
            return False
        if position == 0:
            return self.remove_first()

        current = self.head
        count = 0
        while current and count < position:
            current = current.next
            count += 1

        if not current:
            return False

        if current == self.tail:
            return self.remove_last()

        current.prev.next = current.next
        current.next.prev = current.prev

        return True

```
优点：空间占有率：O(n),每一个O(1),运行时间O(1)

位置列表：能够标识元素的位置
![img_6.png](img_6.png)

![img_25.png](img_25.png)

# 树 Tree
一些名词：
![img_7.png](img_7.png)
![img_8.png](img_8.png)

树的遍历方式：
preorder Traversal前序遍历：

先访问其节点的数据，然后再访问后代的节点

postorder traversal后序遍历：

先访问其后代的节点，再访问它的数据

Breadth-First Traversal广度优先遍历：

在广度优先遍历中，每个级别的所有节点都先于其后代访问

## 二分树 binary trees

### 属性：
1，每一个内部的节点最有2个孩子

2，每个节点的孩子是有顺序的(ordered pair)

![img_9.png](img_9.png)

递归定义：Alternative recursive definition: a binary tree is either n a tree consisting of a single node, or n a tree whose root has an ordered pair of children, each of which is a binary tree

替代递归定义：二叉树要么是 n 个由单个节点组成的树，要么是 n 个根具有一对有序子节点的树，每个子节点都是二叉树

应用：

1,算术表达树：只有叶子代表数字，其他都代表着运算符

2，决策树：

### 二叉树的Inorder Traversal of Binary Trees中序遍历

节点在其左子树之后，右子树之前被访问

![img_10.png](img_10.png)

### 二叉树的实现：

1，ADT的实现：

![img_26.png](img_26.png)

2，数组的实现：
左孩子=2*父节点+1

右孩子=2*父节点+2


# Map
可搜索的项的集合，key-value的形式

多个item不可能拥有相同的key,但是可以为同一个value提供同一个key
![img_11.png](img_11.png)


# 字典dict
在这里，我们在专门讨论 Python 的 dict 类时使用术语“dictionary”，在讨论抽象数据类型的更一般概念时使用术语“map”。

# 哈希表

物品比存储的空间还要多：使用桶
![img_12.png](img_12.png)
我们可以使用哈希函数将项目分配给存储桶数组中的索引

## 哈希函数：
哈希表是实现映射的最实用的数据结构之一。
Python的字典被实现为哈希表。

1，hash code将一个key映射到一个整数上

2，compression function:将哈希代码映射到存储桶数组的索引 [0， N-1] 范围内的整数

We can use a hash function to allocate items to indexes in bucket arrays我们可以使用哈希函数将项目分配给存储桶数组中的索引

![img_27.png](img_27.png)

![img_13.png](img_13.png)

![img_14.png](img_14.png)

## 哈希函数的意义：

    哈希函数旨在随机分散键 哈希函数通常被指定为两个函数的组合：
    哈希码： h1：键->整数 
    压缩函数： h2： 整数 -> [0， N - 1] 
    首先应用哈希码，然后对结果应用压缩函数，即 h（x） = h2（h1（x））希函数的目标是以一种看似随机的方式“分散”键

![img_15.png](img_15.png)

![img_16.png](img_16.png)

![img_17.png](img_17.png)

![img_18.png](img_18.png)

# 二叉搜索树：


搜索表：A search table is an ordered map implemented by means of a sorted sequence搜索表是通过排序序列实现的有序映射

Binary Search Trees：

![img_28.png](img_28.png)

![img_29.png](img_29.png)

## 二叉搜索树的的中序遍历：
可以以递增的顺序访问键
###　搜索：
![img_19.png](img_19.png)
```python
def search(root,key):
     
    # Base Cases: root is null or key is present at root
    if root is None or root.val == key:
        return root
 
    # Key is greater than root's key
    if root.val < key:
        return search(root.right,key)
   
    # Key is smaller than root's key
    return search(root.left,key)

```
### 插入：
![img_20.png](img_20.png)

```python
def insert(root, key):
    if root is None:
        return Node(key)
    
    prev = None
    temp = root

    while temp:
        if temp.val > key:
            prev = temp
            temp = temp.left
        elif temp.val < key:
            prev = temp
            temp = temp.right

    if prev.val > key:
        prev.left = Node(key)
    else :
        prev.right = Node(key)


    return root
```
### 删除：
![img_21.png](img_21.png)