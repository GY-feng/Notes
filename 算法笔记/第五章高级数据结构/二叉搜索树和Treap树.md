# 二叉搜索树（BST）
## 特征：
    1，每个元素唯一的键值，一般放在树的结点上
    2，任意一个结点的键值，比其左子树的结点的键值要大，比其所有右节点的键值小。
    3，用中序遍历可以获得二叉搜索树的有序排列
    4，插入删除操作详见以前的笔记
## 算法的区别：
    区别在于用什么方法动态调整使得树是平衡的
# Treap树：
Treap可以翻译成树堆
二叉搜索树的结点本身有个键值，除此之外，Treap树为每个节点人为地添加了1个被称为优先级的键值
对于键值而言，树是排列二叉树；对于优先级而言，树是一个堆
建树的过程详见P73
    
如何给优先级？随机赋值，虽然不能保证每次生成的Treap树是一样的，但能保证插入，删除，查找的时间复杂度都是log2n的
## 树的插入&建树：
    按照优先级排序，然后按照优先级从高到低的顺序插入即可
### 对上述方法的优化:
每读入一个新节点，为它随机分配一个优先级，插入树当中，再动态调整树的结构
    过程：
    1，将节点按照键值先插入到合适的子树上。
    2，给节点随机分配一个优先级，如果节点的优先级违反了堆的性质，那么让节点往上走，代替父节点，形成新的树
    3,子树的优先级比父节点高=>左旋
```c++
//上述过程的调整技巧：旋转，其中son[0]是左儿子，son[1]是右儿子
void rotate(Node* &o,int d )//d=0,左旋转；d=1，右旋转
{
    Node *k=o->son[1-d];//[1-d]可以用[d^1]优化，更快
    /*这一行创建了一个指针 k，它指向节点 o 的子节点中的一个。
    子节点的选择基于 d 的值：如果 d 为 0，则 k 指向 o 的右子节点；
    如果 d 为 1，则 k 指向 o 的左子节点。这是旋转操作的关键之一，将子节点提升为新的根节点。
    */
    o->son[d^1]=k->son[d];
    /*
    这一行将节点 o 的特定子节点设置为节点 k 的特定子节点
    。d^1 是异或操作的结果，用于切换 d 的值。这行代码实现了将节点 k 的相应子节点移动到节点 o 的特定位置，
    以保证旋转的正确性。
    */
    k->son[d]=o;
    //这一行将节点 k 的特定子节点设置为节点 o，完成了旋转操作的另一部分。
    o=k;
    //最后，这行代码将节点 o 更新为节点 k，实际上将二叉树中的根节点更改为新的节点 k。
}
```
## 树的删除：
1，节点x是叶子节点=>直接删除
2，待删除的节点X有两个子节点，找到优先级最大的子节点，将X向相反的方向旋转（向树的下层调整）知道到达了叶子节点，再直接删除
## 应用：Treap树和名次树的问题
    少林寺和尚问题：先对老和尚的等级进行排序，在加入一个新和尚的时候，找到等级最接近的老和尚，输出老和尚的id
    两种解法：map和treap树