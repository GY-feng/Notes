# 注意事项

    1，本文由枫总结与2023.12.13
    2，本文主要使用C++，少部分使用py
    3，由于懒，本文是由window自动合并文件，其顺序为：
    10子集枚举.md
    11贪心法.md
    12前缀和.md
    13排列枚举.md
    14离散化.md
    15并查集.md
    16差分.md
    17分治法.md
    18二分搜索和查找.md
    19二叉搜索树和Treap树.md
    1C++入门学习.md
    20基础DP..md
    21Treap树的实现.md
    2香农班上课.md
    3learncpp.md
    4STL.md
    5.1并查集.md
    5做题有感.md
    6搜索.md
    7递推与递归.md
    8BFS1.md
    9DFS.md

# 子集枚举

子集的情况可以使用二进制来表示

## 几种集合的表示情况

    1，表示仅包含第i个元素的集合的二进制表示成：1<<(i-1)
    2,所有元素的全级：
    (1<<n)-1
    3，空集为0

## 集合的常用关系

    1，并集：A1是A2和A3的并集，则A1的每一位是A2和A3的结果，则按位或运算：a1=a2|a3
    2，交集：同上，两个子集进行与操作：a1=a2&a3
    3，包含：判断A2所有元素在A1上是否有：(a1|a2==a1)&&(a1&a2==a2)
    4，属于：（包含的特殊情况）检查某元素是否在一个集合当中：采用左位移运算符构造出那个仅含一项的集合，然后再和原集合取交，若不为空集，则真命题，eg:判断第i个元素是否属于A1：1<<(i-1)&a1
    5，补集：a^a2

## 子集问题当中常用的库函数

    __builtin_popcount():它能直接返回一个数二进制下1的个数

## 好用的函数

    1，有一个集合S，当中有n个元素，想判断第i个数是否在S当中：

```c++
bool isElementInSubset(int subset, int i) {
    // 使用位运算检查第i位是否为1
    return (subset & (1 << i)) != 0;
}
//使用了位运算来检查给定的整数 subset 中的第 i 位是否为1。
/*
左移运算 (<<)： 左移运算符将一个二进制数的所有位向左移动指定的位数。例如，1 << i 表示将1左移 i 位。在二进制中，这就等同于在右侧添加 i 个零。

例子：如果 i 是2，那么 1 << i 就是二进制的 100。

按位与运算 (&)： 按位与运算符对两个二进制数的每一位执行与操作。只有当两个相应的位都为1时，结果的相应位才为1。
例如，假设 subset 的二进制表示是 0010010，而 i 是2。在这种情况下， (1 << i) 就是 00000100。按位与运算后的结果是 00000100，这不等于零，因此 isElementInSubset 返回 true，表示 subset 中的第 i 位为1。
*/
```# 贪心法：
    删数问题：用到string 的earse(i,j)函数
```c++
        //思路：找高峰期
    int s,i;
    cin>>n>>s;
    while(s)
    {
        for(i=0;n[i]<=n[i+1];)//找到了1个高峰辽
        {
            i++;
        }
        n.erase(i,1);//删除函数，从第i个位置删除1个
        s--;
    }
    while(n[0]=='0'&&n.size()>1)
    {
        //处理前导0，如果长度是1就不能删啦
        n.erase(0,1);
    }
```

## 哈夫曼编码

    二叉树编码
    1，每个二叉树的分支，左0右1，叶子的末端是编码，可以保证前缀不包含的要求
    2，出现频次最高的字符，放在靠近根节点上，最短，频次低的字符则在最长的地方
    3，整个二叉树由底端（出现低）向顶端构建，父节点的值是子节点的值的和

```c++
//Work By:优先队列：poj1521
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    priority_queue<int,vector<int>,greater<int>> Q;//优先队列，最小的在队首
    while(getline(cin,s)&&s!="END")//输入字符
    {
        int t=1;
        sort(s.begin(),s.end());//字典序排序
        for(int i=1;i<s.length();i++)
        {
            if(s[i]!=s[i-1])
            {
                Q.push(t);
                t=1;
            }
            else 
                t++;
        }
        Q.push(t);
        int ans=0;
        while(Q.size()>1)
        {
            int a=Q.top();Q.pop();
            int b=Q.top();Q.pop();//提取队列当中最小的两个
            Q.push(a+b);
            ans+=a+b;//直接计算编码的长度即可
        }
        Q.pop();
    }
}
```

## 模拟退火（紫、蓝专题）# 前缀和

## What

    一种预处理，可简单理解成[数列的前n项之和]，可大大降低查询的时间复杂度
    个人理解：用于求某个特定区间的和
    前缀和：sum[i]=a[1]+a[2]+...+a[i];
    递推公式：sum[i]=sum[i-1]+a[i]

## 注意

    数组的下标从1开始，因为递推公式的原图，需将前缀和数组初始化为0或仅将sum[0]初始化为0

## eg

    求a[3]+a[4]+...+a[57]:
    等于S[57]-(a[1]+a[2])S为求和函数
    即：sum[57]-sum[3-1]
    原本O(r-l)的复杂度被压缩成O(1)

## 扩展：高维前缀和

# 离散化
标准定义：离散化 (discretization) 是把无限空间中有限的个体映射到有限的空间中去。
一种离散化的实现：把绝对大小转化为相对大小。
当值域跨度很大，而真实不同的取值个数很少时，可以用离散化的方法把值域调整为取值个数。
离散化+计数排序的实现：借助 。
定义 ， 表示 出现了多少次。
得到排序后原数组的实现代码：
考虑到 自带的复杂度，时间复杂度为
也可以用 ，下同。
得到排序后离散化数组的实现代码：
for (int i = 1; i <= n; ++i)
{
++cnt[a[i]];
}
for (int i = 1, s = 0; i <= k; ++i)
{
s += cnt[i];
cnt[i] = s - cnt[i];
}
for (ll i = 1; i <= n; ++i) //倒着也行
{
b[++cnt[a[i]]] = a[i];
}
for (ll i = 1; i <= n; ++i)
{
h[a[i]]++; //h是map<ll, ll>
}
for (auto i : h)
{
for (ll j = 0; j < i.second; ++j)
{
a[++ai] = i.first; //ai初始值为0
}
}
时间复杂度为
直接得到离散化数组的实现代码：
时间复杂度为排序复杂度
copy, sort, unique 都是常用的 STL 函数。( copy 即 memcpy )

# 高级数据结构

## 数据结构作用

1，存储的空间效率eg:存储地图用nxn的二维矩阵表示，虽然速度很快，但是非常浪费空间，故应当采用更高效的数据结构，邻接表
2，访问的效率，搜索当中，先按照一定 的顺序排好序再搜索，更有效率

## 补充：三元运算符

C++中的三元运算符的语法如下：

```c++
condition ? expression1 : expression2
```

condition 是一个布尔表达式，它决定了要返回的值是 expression1 还是 expression2。
如果 condition 为真，那么三元运算符返回 expression1 的值。
如果 condition 为假，那么三元运算符返回 expression2 的值。

## 并查集

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1050;
int s[maxn+1];//用s存储每个元素的父节点s[i]=j代表着i的父节点是j
int height[maxn+1];//合并的优化时候使用
void init_set()//初始化集合，开始的时候，将父节点设置为自己
{
    for (int i =1; i <=maxn; i++)
    {
        s[i]=i;
        height[i]=0;//树的高度
    }
}
int find_Set(int x)//查找,(已经进行了路径优化)
{
    if (s[x]==x)
    {
        return x;
    }
    else//优化,eg:在查找4的时候，将4的父节点设置为1而不再是3，3的父节点设置为1，减少查询次数（并查集必须写！！！）

    {
        s[x]=find_Set(s[x]);
        return s[x];
    }
    //return x==s[x]?x:find_Set(s[x]);
}
int find_set_without_stack(int x)//上面的代码采用栈的方式实现，如果怕栈爆掉，采用以下的方式：
{
    int root =x;
    while(s[root]!=root)root=s[root];//查找根节点
    int i=x,j;
    while(i!=root)
    {
        j=s[i];//临时变量记录
        s[i]=root;//把路径上的元素的集改为根节点
        i=j;
    }
    return root;
}
void union_set(int x,int y)//合并
{
    x=find_Set(x);//找到x,y的祖先
    y=find_Set(y);
    //if(x!=y)s[x]=s[y];//    i的祖先指向j的祖先
 //合并操作的优化：将高度较小的集合合并到大的集合上，以减少树的高度，
    if(height[x]==height[y])
    {
        height[x]=height[y]+1;//合并，树的高度加一
        s[y]=x;//祖先移动
    }
    else
    {
        if(height[x]<height[y])
        {
            s[x]=y;
        }
        else
        {
            s[y]=x;
        }

    }
}
int main()
{
    int t,n,m,x,y;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        init_set();
        for (int i = 1; i <=n; i++)
        {
            cin>>x>>y;
            union_set(x,y);
        }
        
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(s[i]==i)
        ans++;
    }
    cout<<ans<<endl;
}
//合并的优化：
int height[maxn+1];
void union_set_pro(int x,int y)//合并
{
    x=find_Set(x);
    y=find_Set(y);
    if(x!=y)s[x]=s[y];
}
}
```

上述代码当中，union_set()和find_set()的搜索深度为树的长度，复杂度是O(n)，太低了！

# 差分

## WHAT

    相对于前缀和的思想，即：原数组是差分数组的前缀和
    从下标为1的数组开始，b(i)=a(i)-a(i-1)

## Where

    用于需要多从进行区间加操作，即对数组中的某个区域[l,r]内的所有数加上一个相同的值，然后查询数组上某个数或者所有数值的题目，在a区间[l,r]内均加上X，在差分数组当中将b(l)加上x而将b(r)减去X（开数组范围大点防止越界）

## 注意

    差分只能用在查询操作全部在修改操作后的情况# 分治法：
    操作思路：将问题分成k个较小规模的小问题，分别求解。

## 特征

    1，平衡子问题：子问题的规模差不多，k个，最好k=2
    2，独立子问题：子问题之间相互独立（区别于DP！！！）

## 解题步骤

    1，分解
    2，解决（递归）
    3，合并

## 应用

    归并排序，快速排序，汉诺塔
逆序对问题# 二分搜索和查找

## 二分基本

    注意这里的指针l和r，对应一个左开右闭区间[l,r)

```c++
int solve(int x)
{
        int l=1,r=n+1;
        while (l<r)//最后r和l会相等
        /*
        修改后的代码，尤其注意+1，-1的问题
        如果有多个待查找的数据并且要找到最大的数字编号
        改成：
            if(a[mid]<=x)l=mid+1;
            else r=mid;
        */
        {
            int mid=(l+(r-1))/2;
            //有时候l+r可能会超过int 类型的极限,r-1可以避免运算溢出
            if(a[mid]>=x)
            {
                r= mid;
            }
            //else if(a[mid]>x)r=mid-1;//取区间的前一半
            else l=mid+1;//取区间的后一半
        }
        if(a[l]==x)
            return l;
        else
            return -1;
}
```

## 转化的思想，转化成二分&&&STL库函数当中的运用

### 介绍STL函数

lower_bound(begin,end,val);
在有序的数组的连续地址[begin,end)找到第一个位置并且返回地址
（最后减去“这个数组”才能得到具体的位置，使得val插在这个位置前，数组依然有序）
upper_bound(begin,end,val);找到最后一个位置并且返回地址，使得val插在这个位置后

```c++
//复杂度nlogn的算法：
#include<bits/stdc++.h>
using namespace std;
/*
分析：
枚举A，那么就是要统计在数组当中B+C出现了多少次，
数列排序后B+C对应某段的左端点和右端点
*/
typedef long long ll;
ll a[200010];
ll n,c;
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    ll total=0;
    sort(a+1,a+n+1);
    for (int i = 1; i <= n; i++)
    {
        ll x =a[i]+c;
        total+=((upper_bound(a+1,a+n+1,x)-a)-(lower_bound(a+1,a+n+1,x)-a));
    }
    cout<<total;
    //cin>>n;
}
//改进版本：
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    ll total=0;
    sort(a+1,a+n+1);
    for(int i=0,L=0,R=0;i<n;i++)
    {
        //两个指针的移动次数不超过n
        while(L<n&&a[L]<a[i]+c)
        {
            L++;//L相当于lower_bound，第一个a[L]>=a[i]+c的位置
        }
        while (R<n&&a[R]<=a[i]+c)
        {
            R++;//R相当于upper_bound，第一个a[R]>a[i]+c的位置
        }
        total+=R+L;
    }
    cout<<total;
}
```

## 二分答案

    单调性判定问题
另外的一种二分代码写法，不必考虑+1和-1的问题！：
只需要想清楚程序当中的答案是否需要更新（是否要记下ans)
并且要想清楚可能的答案在哪一册（改L还是R即可）

```c++
int Find(int L,int R)//使用前确保答案在[L,R]内//注意，开始的L=0，数组从第1位开始放数字捏
{
    int ans,mid;
    while(L<=R)//闭区间上的二分条件
    {
        int mid=L+R>>1;
        if(P(mid))//条件成立
            ans=mid;R=mid-1;
            //只需要记录满足条件的mid，最后循环一定会结束，也一定会在ans当中保留正确的答案
        else 
            L=mid+1;//L和R不用考虑+1和-1，全部写上去
    }
    return ans;
}

```

### 使用二分条件技巧的条件

1，命题可以归纳成为找到使得命题P(x)成立/不成立的最大/最小的x
2，将P(x)看做一个真或者假的函数，那么它一定在某个分界线的一侧全为真，另一侧全为假
3，可以找到一个复杂度优秀的算法检验P(x)的真假

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m;
ll trees[1000005];
/*
分析，固然可以从1m往上一直枚举，但是复杂度是n×h太慢了
判断单调性：
当x超过某个数的时候，条件一定是不成立的，而当不超过这个数的时候，条件一定成立
完全符合二分条件！
*/
bool P(int h)
{
    ll total=0;
    for (int i = 0; i < n; i++)
    {
        if(trees[i]>h)
        {
            total+=trees[i]-h;
        }
    }
    return total>=m;
}
int main()
{
    cin>>n>>m;
    for (int i = 0; i < n; i++)
    {
            cin>>trees[i];
    }
    sort(trees,trees+n);
    int L=0,R=1e9,ans,mid;
    while (L<=R)
    {
        if(P(mid=L+R>>1))
            ans=mid,L=mid+1;
            //为真，mid可以成为答案，真正的答案可能在mid的右侧，左端点右移动
        else R=mid-1;//答案在mid的左侧，右端点左移
    }
    cout<<ans; 
}
```

使用二分法求解一元三次方程
精度问题：题目要求保留两位小数，那么可以在二分端点相差不超过le-4停止二分以确保精确度

```c++
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d;
#define  eps 1e-4//
double f(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    cin>>a>>b>>c>>d;
    //fabs:这个函数接受一个 double 类型的参数 x，并返回其绝对值
    for (int i = -100; i <=100; i++)
    {
        double L=i,R=i+1,mid;
        if(fabs(f(L))<eps)//L可以是根
        {
            printf("%.21f",L);
        }
        else if(fabs(f(R))<eps)//L可以是根
        {
            //printf("%.21f",R);
            continue;//跳过//等下一个循环当中L变到R了在输出，避免重复输出
        }
        else if(f(L)*f(R)<0)//在（L,R）上有根，则执行二分
        {
            while(R-L<eps)//在二分端点相差不超过10负四次方停止二分保持精度
            {
                mid=(R+L)/2;
                if(f(mid)*f(R)>0) R=mid;
                //mid和R的正负形是相同的，说明零点在mid的左侧
                else L=mid;//否则就是在另一侧
            }
            printf("%.21f",L);
        }
    }
    
}

```

## 二分法模板的应用

*** 12:6:
    建议使用上面给出的模板

```c++
#include<bits/stdc++.h>
using namespace std;
double n,m,k,l,r;
bool pd(double x){//判断当前答案是否满足 
 return (pow(1.0/(1.0+x),k)>=1-n/m*x);//pow函数，上文已讲
}
int main(){
 cin>>n>>m>>k;
    ///////////////////////二分模板
 l=0;r=10;//月利率可能大于1
 while(r-l>=0.0001){//注意精度问题 
  double mid=(l+r)/2;
  if(pd(mid))r=mid;
  else l=mid;
 }
    ///////////////////////
 cout<<fixed<<setprecision(1)<<l*100;//输出一位小数哦 
    cin>>n;
 return 0;
} 
```

# 二叉搜索树（BST）

## 特征

    1，每个元素唯一的键值，一般放在树的结点上
    2，任意一个结点的键值，比其左子树的结点的键值要大，比其所有右节点的键值小。
    3，用中序遍历可以获得二叉搜索树的有序排列
    4，插入删除操作详见以前的笔记

## 算法的区别

    区别在于用什么方法动态调整使得树是平衡的

# Treap树

    Treap可以翻译成树堆
    二叉搜索树的结点本身有个键值，除此之外，Treap树为每个节点人为地添加了1个被称为优先级的键值
    对于键值而言，树是排列二叉树；对于优先级而言，树是一个堆
    建树的过程详见P73
    
    如何给优先级？随机赋值，虽然不能保证每次生成的Treap树是一样的，但能保证插入，删除，查找的时间复杂度都是log2n的

## 树的插入&建树

    按照优先级排序，然后按照优先级从高到低的顺序插入即可

### 对上述方法的优化

每读入一个新节点，为它随机分配一个优先级，插入树当中，再动态调整树的结构
    过程：
    1，将节点按照键值先插入到合适的子树上。
    2，给节点随机分配一个优先级，如果节点的优先级违反了堆的性质，那么让节点往上走，代替父节点，形成新的树
    3,子树的优先级比父节点高=>左旋

```c++
//上述过程的调整技巧：旋转，其中son[0]是左儿子，son[1]是右儿子
void rotate(Node* &o,int d )//d=0,左旋转；d=1，右旋转
{
    Node *k=o->son[1-d];//[1-d]可以用[d^1]优化，更快
    /*这一行创建了一个指针 k，它指向节点 o 的子节点中的一个。
    子节点的选择基于 d 的值：如果 d 为 0，则 k 指向 o 的右子节点；
    如果 d 为 1，则 k 指向 o 的左子节点。这是旋转操作的关键之一，将子节点提升为新的根节点。
    */
    o->son[d^1]=k->son[d];
    /*
    这一行将节点 o 的特定子节点设置为节点 k 的特定子节点
    。d^1 是异或操作的结果，用于切换 d 的值。这行代码实现了将节点 k 的相应子节点移动到节点 o 的特定位置，
    以保证旋转的正确性。
    */
    k->son[d]=o;
    //这一行将节点 k 的特定子节点设置为节点 o，完成了旋转操作的另一部分。
    o=k;
    //最后，这行代码将节点 o 更新为节点 k，实际上将二叉树中的根节点更改为新的节点 k。
}
```

## 树的删除

    1，节点x是叶子节点=>直接删除
    2，待删除的节点X有两个子节点，找到优先级最大的子节点，将X向相反的方向旋转（向树的下层调整）知道到达了叶子节点，再直接删除

## 应用：Treap树和名次树的问题

    少林寺和尚问题：先对老和尚的等级进行排序，在加入一个新和尚的时候，找到等级最接近的老和尚，输出老和尚的id
    两种解法：map和treap树# C++学习：

## 主函数

    除了int main()以外也可以写成signed main()或者int32 main()是一样的意思，一方如果需要把全文的int替换成long long

## 输入输出流

cin>>变量名，这个表达式本身会返回一个布尔值，表示当前是否读到了EOF，为false则表示遇到了EOF

```c++
#include <bits/stdc++.h>
using namespace std;
int v, sum;
signed main()
{
while (cin >> v)
{ //类比EOF!=scanf("%d",&v)
sum += v;
}
cout << sum;
return 0;
}
```

读写加速：
使用了读写加速后，不能同时使用 cin,scanf 与 cout,printf ，否则可能出错

```c++
ios::sync_with_stdio(false);//false即0,是C++的布尔值bool类型
cin.tie(0); //0即空指针，可以写成C++的nullptr或C语言的NULL
cout.tie(0);
```

## 传引用

使用 变量类型& 传引用变量名 定义一个传引用变量(称为左值传引用)。
赋值一个传引用变量，直接把变量赋给它即可，即 传引用变量名 = 被引用变量名 。声明时必须赋值，且不能改变初始化再指向其他对象。
传引用可以视作一个变量的别名。即调用传引用等效于调用被引用变量本身。如：

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
int x = 114515;
int &y = x;
--y;
printf("%d %d", y, x);//都是114514
return 0;
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
void myswap(int &x, int &y)
{
int t = x;
x = y;
y = t;
}
int main()
{
int a = 233, b = 666;
myswap(a, b);
cout << a << ' ' << b; // 666 233
return 0;
}
```

传引用的功能是代替指针。特别注意不能传引用一个数组。
使用传引用的目的：
修改值
对很大的数据对象(结构体)，提高运行速度，避免拷贝
对于认为不需要修改值的用途里，可以写成 const 类型& 变量 。这在重载比较函数里很常用。

## 重载运算符

多维数组适合开普通的数组

```c++
返回值 operator 运算符(左参数, 右参数)
{
函数体
}
```

## sort函数

需要逆序即使用 greater<类型>() 即可获得该函数变量。
升序同理 less<类型>() 。如上述代码改为：

```c++
sort(a, a + 3, greater<int>());
```

## for-each 函数

```c++
//for-each:
    int x[5]={2,3,4,5,6};
    for(int v:x)//可以用这个来简单的输出一个vector的元素
    {
        cout<<v<<endl;
    }
    vector<int> a={2,3,4,5,6};
    for(int x:a)
    {
        cout<<x<<endl;
    }
```

## 匿名函数

```c++
    auto f=[](int a ,int b){return a+b;};//匿名函数
```

## 保留小数

要输出特定位小数，如保留小数点后九位，则使用

```c++
cout<<fixed<<setprecision(9)<<x；
```

# 深度搜索基本模板

```c++
int search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```

# DP算法  

    简单解释：多阶段决策问题，将一个复杂的问题分解成相对简单的子问题，
    这些子问题前后相关，非常相似，处理方法几乎一样。
    将前问题的计算结果记录为“状态”，存储在“状态表”当中，后面的子问题查询状态表得知前面问题的答案，减少复杂度

## 一般思路

    1，穷举法、暴力搜索穷举答案，画出递归树，尝试采用递归来进行求解
    2，如果发现存在大量的重复计算，记忆化搜索（哈希表缓存），遍历到相同的节点就直接查表
    3, 将计算的过程表示出来，观察计算的公式求解的顺序 ，尝试将递归形成改写成迭代形式（例如：两个for循环） 

## 区别于分治法

    DP之间的问题是相关的，前面问题的解决结果可以被后面的子问题利用

## 适用

    有重叠子问题和最优子结构性质的问题

## 步骤

    1，定义状态
    2，状态转移
    3，算法实现

## 核心：状态、状态转移方程

    用状态转移方程求解状态，状态往往就是问题的解

## 分类

### 线性dp

    顺推和逆推，常用“表格”来处理状态，清晰地演示推导过程

### 非线性dp

    eg:树形dp
    两个方向：
        1，根->叶，传递有用的信息给子节点，最后根得出最优解
        2，叶->根，根的子节点传递有用的信息给根，最后根得最优解

# 基础dp

## 7.1.1硬币问题

### 最少硬币个数问题

```c++
#include<bits/stdc++.h>
using namespace std;
//最少硬币问题
const int MONEY=251;//最多金额
const int VALUE=5;//5种面值
int type[VALUE]={1,5,10,25,50};
int Min[MONEY];//每个金额对应的最少的硬币数量
void solve()
{
    for(int k=0;k<MONEY;k++)
        Min[k]=INT_MAX;
    Min[0]=0;
    for(int j=0;j<VALUE;j++)
        for(int i=type[j];i<MONEY;i++)
            Min[i]=min(Min[i],Min[i-type[j]]+1);
}//不断“优化”最优解，1个，5个，10个，25个...
int main()//打表的思路
{
    int s;
    solve();
    while(cin>>s)
    {
        cout<<Min[s]<<endl;
    }
    return 0;
}
```

### 打印最少硬币的组合

```c++
#include<bits/stdc++.h>
using namespace std;
//打印最少硬币的组合：要增加一个记录表Min_path[i]记录金额i所需的最后一个硬币，利用这个数组倒推就能得到所有的硬币

const int MONEY=251;//最多金额
const int VALUE=5;//5种面值
int type[VALUE]={1,5,10,25,50};
int Min[MONEY];//每个金额对应的最少的硬币数量
int Min_path[MONEY]={0};//记录最小硬币的路径
void solve()
{
    for(int k=0;k<MONEY;k++)
        Min[k]=INT_MAX;
    Min[0]=0;
    for(int j=0;j<VALUE;j++)
        for(int i=type[j];i<MONEY;i++)
            if(Min[i]>Min[i-type[j]]+1)
            {
                Min_path[i]=type[i];//在每个金额上记录路径，即某个硬币的面值
                Min[i]=min(Min[i],Min[i-type[j]]+1);
            }
}//不断“优化”最优解，1个，5个，10个，25个...
void print_ans(int *Min_path,int s )
{
    while(s)
    {
        cout<<Min_path[s]<<" ";
        s=s-Min_path[s];
    }
}
int main()//打表的思路
{
    int s;
    solve();
    while(cin>>s)
    {
        cout<<Min[s]<<endl;
    }
    return 0;
}
```

# Treap树的实现（题目：shaolin）

```c++
#include<map>
#include<vector>
#include<iostream>
using namespace std;
//Treap树代码
int id[5000000 + 5];
struct Node
{
 int size;//以这个节点为根的子树的节点总数量，用于名次树
 int rank;//优先级
 int key;//键值
 Node* son[2];//0是左儿子，1是右儿子
 bool operator <(const Node& a)const { return rank < a.rank; }
 int cmp(int x)const//const修饰符在成员函数声明中表示该成员函数不会修改类的数据成员。
  //它可以用于对于只读操作或不修改对象状态的操作进行标记，以增加代码的清晰性和安全性。
 {
  if (x == key)return -1;
  if (x < key)
  {
   return 0;
  }
  else
   return 1;
 }
 void update()//更新size
 {
  size = 1;
  if (son[0] != NULL)size += son[0]->size;
  if (son[1] != NULL)size += son[0]->size;
 }
};
void rotate(Node*& o, int d)//d=0:左旋；d=1:右旋
{
 Node* k = o->son[d ^ 1];//位操作优化性能
 o->son[d ^ 1] = k->son[d];
 k->son[d] = o;
 o->update();
 k->update(); o = k;
}
void insert(Node*& o, int x)//将x插入到树当中
{
 if (o == NULL)
 {
  o = new Node();
  o->son[0] = o->son[1] = NULL;
  o->rank = rand();
  o->key = x;
  o->size = 1;
 }
 else
 {
  int d = o->cmp(x);//如果cmp返回-1，访问son的-1下标，不会报错吗（下标由0开始）？
  insert(o->son[d], x);
  o->update();
  if (o < o->son[d])
   rotate(o, d ^ 1);
 }
}
int kth(Node* o, int k)//找第k大的数
{
 ////如果当前节点 o 为空，或者 k 不在合法范围内（小于等于0或大于树的大小），则返回 -1。
 if (o == NULL || k <= 0 || k > o->size)
  return -1;
 //如果不满足上述条件，它首先计算右子树的大小 s（如果右子树为空则为0）
 int s = o->son[1] == NULL ? 0 : o->son[1]->size;
 //然后它与 k 比较，如果 k 等于 s + 1，则表示当前节点 o 就是第k大的数，返回 o->key。
 if (k = s + 1)return o->key;
 //如果 k 小于等于 s，则说明第k大的数在右子树中，递归地在右子树 o->son[1] 中查找第k大的数。
 else if (k <= s)return kth(o->son[1], k);
 //否则，第k大的数在左子树中，递归地在左子树 o->son[0] 中查找第 k - s - 1 大的数。
 else return kth(o->son[0], k - s - 1);
}
int find(Node* o, int k)//返回元素k的名次
{//如果当前节点 o 为空，说明没有找到元素 k，返回 -1
 if (o==NULL)
 {
  return -1;
 }
 //首先，它使用 o->cmp(k) 函数来比较元素 k 和当前节点的值，得到比较结果 d。
 // 如果 d 等于 -1，表示元素 k 等于当前节点值，返回右子树的大小加1（如果右子树为空则为1），
 // 表示当前节点是第 k 大的数。
 int d = o->cmp(k);
 if (d == -1)
  return o->son[1] == NULL ? 1 : o->son[1]->size + 1;
 //如果 d 等于 1，表示元素 k 大于当前节点值，递归地在右子树 o->son[1] 中查找元素 k。
 else if (d == 1)return find(o->son[d], k);
 //否则，d 等于 0，表示元素 k 小于当前节点值，它递归地在左子树 o->son[0] 中查找元素 k。
 else
 {
  //如果在左子树中找到了元素 k，它将返回 tmp + 1 + o->son[1]->size，其中 tmp 是元素 k 在左子树中的名次
  // o->son[1]->size 是右子树的大小，因此返回的是整个树中元素 k 的名次。
  int tmp = find(o->son[d], k);
  if (tmp == -1)
  {
   return -1;
  }
  else
   return o->son[1] == NULL ? tmp + 1 : tmp + 1 + o->son[1]->size;
 }
}


int main()
{
 int n;
 while (~scanf("%d", &n) && n)
 {
  srand(time(NULL));//time(NULL)返回当前的时间（自 1970 年 1 月 1 日以来经过的秒数）。srand函数是用来设置随机数发生器的种子，
  //它需要一个整数作为种子。种子的选择会影响随机数生成的序列。通常情况下，我们希望每次程序运行时生成的随机数序列都是不同的，而不是每次都产生相同的序列。
  //因此，srand(time(NULL)) 的作用是使用当前时间作为种子，以确保每次程序运行时都会产生不同的随机数序列。这样做可以增加随机性，
  //使得每次运行程序时得到的随机数序列都是不同的。通常这是在需要产生伪随机数的程序中使用的常见技巧。
  int k, g;
  scanf("%d%d", &k, &g);
  //创建一个新的二叉搜索树节点 root，并初始化其属性，包括左右子树为 NULL，随机排名 
  //rank，关键字 key 为 g，以及大小 size 为 1。同时，将 id[g] 赋值为 k。
  Node* root = new Node();
  root->son[0] = root->son[1] = NULL;
  root->rank = rand(); root->key = g; root->size = 1;
  id[g] = k;
  //表示当前输入的 k 和相应的排名为 1。
  printf("%d%d\n", k, 1);
  for (int i = 2; i <= n; i++)
  {
   scanf("%d%d", &k, &g);
   id[g] = k;
   //调用 insert(root, g) 将新的关键字 g 插入二叉搜索树。
   insert(root, g);
   //调用 find(root, g) 获取关键字 g 在二叉搜索树中的名次，保存在变量 t 中。
   int t = find(root, g);
   //调用 kth(root, t - 1) 和 kth(root, t + 1) 获取第 t - 1 和第 t + 1 大的数，分别保存在变量 ans1 和 ans2 中。
   int ans1, ans2, ans;
   ans1 = kth(root, t - 1);//找比t-1大的数
   ans2 = kth(root, t + 1);
   //根据一定的条件判断，更新 ans 的值，最后输出格式化的结果 printf("%d%d\n", k, id[ans])，
   // 表示当前输入的 k 和关键字 ans 对应的名次。
   //这是一个条件判断语句。它首先检查变量 ans 是否不等于 -1（即之前没有找到有效的 ans），
   // 并且 ans2 也不等于 -1。
   if (ans != -1 && ans2 != -1)
    //如果两者都满足条件，说明 ans 和 ans2 都有效，可以比较它们的差值，然后根据差值的大小来决定选择哪一个作为新的 ans。
    // 如果 ans1 - g 和 g - ans2 相等，那么选择 ans2，否则选择差值更小的那个。
    ans = ans1 - g >= g - ans2 ? ans2 : ans1;
   //如果上述条件不成立，那么检查 ans 是否等于 -1。如果等于 -1，说明之前没有有效的 ans，此时直接将 ans2 赋值给 ans。
   else if (ans == -1)ans = ans2;
   //如果前两个条件都不满足，那么说明 ans 和 ans2 都是有效的，但是它们的差值比较大。此时，直接将 ans1 赋值给 ans。
   else ans = ans1;
   printf("%d%d\n", k, id[ans]);
  }

 }

}

```

# 计数排序

太大了：map离散化

# 归并排序

分治的思想
可以求逆序对

# STL库

lower_bound();//只能在有序的数组，要想获得下标要减去数组头

# 差分和前缀和

差分：降低复杂度，与前缀和一样的
eg:区间上的数都+1

# 二分

    int mid=l+r+1>>1;//上取整找中点：>>1等同于除以二# C++学习：

## 主函数

    除了int main()以外也可以写成signed main()或者int32 main()是一样的意思，一方如果需要把全文的int替换成long long

## 输入输出流

cin>>变量名，这个表达式本身会返回一个布尔值，表示当前是否读到了EOF，为false则表示遇到了EOF

```c++
#include <bits/stdc++.h>
using namespace std;
int v, sum;
signed main()
{
while (cin >> v)
{ //类比EOF!=scanf("%d",&v)
sum += v;
}
cout << sum;
return 0;
}
```

读写加速：
使用了读写加速后，不能同时使用 cin,scanf 与 cout,printf ，否则可能出错

```c++
ios::sync_with_stdio(false);//false即0,是C++的布尔值bool类型
cin.tie(0); //0即空指针，可以写成C++的nullptr或C语言的NULL
cout.tie(0);
```

## 传引用

使用 变量类型& 传引用变量名 定义一个传引用变量(称为左值传引用)。
赋值一个传引用变量，直接把变量赋给它即可，即 传引用变量名 = 被引用变量名 。声明时必须赋值，且不能改变初始化再指向其他对象。
传引用可以视作一个变量的别名。即调用传引用等效于调用被引用变量本身。如：

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
int x = 114515;
int &y = x;
--y;
printf("%d %d", y, x);//都是114514
return 0;
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
void myswap(int &x, int &y)
{
int t = x;
x = y;
y = t;
}
int main()
{
int a = 233, b = 666;
myswap(a, b);
cout << a << ' ' << b; // 666 233
return 0;
}
```

传引用的功能是代替指针。特别注意不能传引用一个数组。
使用传引用的目的：
修改值
对很大的数据对象(结构体)，提高运行速度，避免拷贝
对于认为不需要修改值的用途里，可以写成 const 类型& 变量 。这在重载比较函数里很常用。

## 重载运算符

多维数组适合开普通的数组

```c++
返回值 operator 运算符(左参数, 右参数)
{
函数体
}
```

## sort函数

需要逆序即使用 greater<类型>() 即可获得该函数变量。
升序同理 less<类型>() 。如上述代码改为：

```c++
sort(a, a + 3, greater<int>());
```

## for-each 函数

```c++
//for-each:
    int x[5]={2,3,4,5,6};
    for(int v:x)//可以用这个来简单的输出一个vector的元素
    {
        cout<<v<<endl;
    }
    vector<int> a={2,3,4,5,6};
    for(int x:a)
    {
        cout<<x<<endl;
    }
```

## 匿名函数

```c++
    auto f=[](int a ,int b){return a+b;};//匿名函数
```

## 保留小数

要输出特定位小数，如保留小数点后九位，则使用

```c++
cout<<fixed<<setprecision(9)<<x；
```

# 深度搜索基本模板

```c++
int search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```

# STL技术

```c++
# include <bits/stdc++.h>
# include <stack>
# include <algorithm>
using namespace std;
const int MAXN = 10;
// 数组的使用：
/*
对于竞赛而言，能使用静态数组则静态数组，空间紧张可以用STL开动态，节约空间，不易出错
*/
vector<int> a(100);                   // 定义100个值为0的元素
vector<string> b(100, "null");        // 十个值为null的元素
vector<string> c(b.begin(), b.end()); // c是b的复制
vector<int> d[MAXN];                  // 定义一个二维数组，它的一维大小是固定的MAXN，二维动态（实现图的邻接表存储）
// vector的索引在常数级别，但是插入和删除速度很慢（要复制内存块）所以少用

// stack的使用：
stack<int> a_stack;

// 队列和queue:
queue<int> q;

// 优先队列priority_queue:
priority_queue<int> pq;
// 优先级别高的元素先出列
// 可以排序，复杂度：nlog2n

// 链表和list:
// list：双向链表，高效地删除和插入
list<int> l;
list<int>::iterator it;

// set集合
// 使用二叉搜索树实现，元素只出现一次，并且是排好序的，
//访问的时间复杂度是log2n
set<int> s;

// map
// map可以实现快速查照，复杂度log2n
map<string, int> m;

// 函数的声明：
void soilder();
int main()
{

    soilder();
    int a = 0;
    cin >> a;
}

// 士兵报数问题：
void soilder()
{
    int t, n;
    cin >> t;
    int k = 3;
    while (t--)
    {
        cin >> n;
        list<int> l_soilder;
        list<int>::iterator it;
        for (int i = 1; i <= n; i++)
            l_soilder.push_back(i);
        while (l_soilder.size() > 3)
        {
            int num = 1;
            if (k == 3)
                k = 2;
            if (k == 2)
                k = 3;
            for (it = l_soilder.begin(); it != l_soilder.end();)
            {
                num++;
                if (num % k == 0)
                {
                    it = l_soilder.erase(it); // 删除后it也会++
                }
                else
                {
                    it++;
                }
            }
        }
        for (it = l_soilder.begin(); it != l_soilder.end(); it++)
        {
            cout << *it;
            cout << " ";
        }
        cout << endl;
    }
}
// 约瑟夫问题
void Table()
{
    vector<int> table;
    int n, m;
    while (cin >> n >> m)
    {
        table.clear(); // 清空上次的数据
        for (int i = 0; i < 2* n; i++)
        {
            table.push_back(i);
        }
        int pos = 0; // 记录下标元素
        for (int i = 0; i < n; i++)
        {
            // 赶走n个人
            pos = (pos + m - 1) % table.size(); // 因为从当前下标开始数起，并且为了不超过，所以进行取余操作
            table.erase(table.begin() + pos);   // 赶走坏人，长度-1
            // 此次的erase执行的速度较慢，少用！
        }
        for (int i = 0, j = 0; i < 2 * n; i++)
        {
            if (j < table.size() && i == table[i]) // 剩下来的都是好人
            {
                j++;
                cout << "G";
            }
            else
            {
                cout << "B";
            }
        }
        cout << endl;
    }
}
```

# 子集枚举

子集的情况可以使用二进制来表示

## 几种集合的表示情况

    1，表示仅包含第i个元素的集合的二进制表示成：1<<(i-1)
    2,所有元素的全级：
    (1<<n)-1
    3，空集为0

## 集合的常用关系

    1，并集：A1是A2和A3的并集，则A1的每一位是A2和A3的结果，则按位或运算：a1=a2|a3
    2，交集：同上，两个子集进行与操作：a1=a2&a3
    3，包含：判断A2所有元素在A1上是否有：(a1|a2==a1)&&(a1&a2==a2)
    4，属于：（包含的特殊情况）检查某元素是否在一个集合当中：采用左位移运算符构造出那个仅含一项的集合，然后再和原集合取交，若不为空集，则真命题，eg:判断第i个元素是否属于A1：1<<(i-1)&a1
    5，补集：a^a2

## 子集问题当中常用的库函数

    __builtin_popcount():它能直接返回一个数二进制下1的个数

## 好用的函数

    1，有一个集合S，当中有n个元素，想判断第i个数是否在S当中：

```c++
bool isElementInSubset(int subset, int i) {
    // 使用位运算检查第i位是否为1
    return (subset & (1 << i)) != 0;
}
//使用了位运算来检查给定的整数 subset 中的第 i 位是否为1。
/*
左移运算 (<<)： 左移运算符将一个二进制数的所有位向左移动指定的位数。例如，1 << i 表示将1左移 i 位。在二进制中，这就等同于在右侧添加 i 个零。

例子：如果 i 是2，那么 1 << i 就是二进制的 100。

按位与运算 (&)： 按位与运算符对两个二进制数的每一位执行与操作。只有当两个相应的位都为1时，结果的相应位才为1。
例如，假设 subset 的二进制表示是 0010010，而 i 是2。在这种情况下， (1 << i) 就是 00000100。按位与运算后的结果是 00000100，这不等于零，因此 isElementInSubset 返回 true，表示 subset 中的第 i 位为1。
*/
```# 贪心法：
    删数问题：用到string 的earse(i,j)函数
```c++
        //思路：找高峰期
    int s,i;
    cin>>n>>s;
    while(s)
    {
        for(i=0;n[i]<=n[i+1];)//找到了1个高峰辽
        {
            i++;
        }
        n.erase(i,1);//删除函数，从第i个位置删除1个
        s--;
    }
    while(n[0]=='0'&&n.size()>1)
    {
        //处理前导0，如果长度是1就不能删啦
        n.erase(0,1);
    }
```

## 哈夫曼编码

    二叉树编码
    1，每个二叉树的分支，左0右1，叶子的末端是编码，可以保证前缀不包含的要求
    2，出现频次最高的字符，放在靠近根节点上，最短，频次低的字符则在最长的地方
    3，整个二叉树由底端（出现低）向顶端构建，父节点的值是子节点的值的和

```c++
//Work By:优先队列：poj1521
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    priority_queue<int,vector<int>,greater<int>> Q;//优先队列，最小的在队首
    while(getline(cin,s)&&s!="END")//输入字符
    {
        int t=1;
        sort(s.begin(),s.end());//字典序排序
        for(int i=1;i<s.length();i++)
        {
            if(s[i]!=s[i-1])
            {
                Q.push(t);
                t=1;
            }
            else 
                t++;
        }
        Q.push(t);
        int ans=0;
        while(Q.size()>1)
        {
            int a=Q.top();Q.pop();
            int b=Q.top();Q.pop();//提取队列当中最小的两个
            Q.push(a+b);
            ans+=a+b;//直接计算编码的长度即可
        }
        Q.pop();
    }
}
```

## 模拟退火（紫、蓝专题）# 前缀和

## What

    一种预处理，可简单理解成[数列的前n项之和]，可大大降低查询的时间复杂度
    个人理解：用于求某个特定区间的和
    前缀和：sum[i]=a[1]+a[2]+...+a[i];
    递推公式：sum[i]=sum[i-1]+a[i]

## 注意

    数组的下标从1开始，因为递推公式的原图，需将前缀和数组初始化为0或仅将sum[0]初始化为0

## eg

    求a[3]+a[4]+...+a[57]:
    等于S[57]-(a[1]+a[2])S为求和函数
    即：sum[57]-sum[3-1]
    原本O(r-l)的复杂度被压缩成O(1)

## 扩展：高维前缀和

# 离散化
标准定义：离散化 (discretization) 是把无限空间中有限的个体映射到有限的空间中去。
一种离散化的实现：把绝对大小转化为相对大小。
当值域跨度很大，而真实不同的取值个数很少时，可以用离散化的方法把值域调整为取值个数。
离散化+计数排序的实现：借助 。
定义 ， 表示 出现了多少次。
得到排序后原数组的实现代码：
考虑到 自带的复杂度，时间复杂度为
也可以用 ，下同。
得到排序后离散化数组的实现代码：
for (int i = 1; i <= n; ++i)
{
++cnt[a[i]];
}
for (int i = 1, s = 0; i <= k; ++i)
{
s += cnt[i];
cnt[i] = s - cnt[i];
}
for (ll i = 1; i <= n; ++i) //倒着也行
{
b[++cnt[a[i]]] = a[i];
}
for (ll i = 1; i <= n; ++i)
{
h[a[i]]++; //h是map<ll, ll>
}
for (auto i : h)
{
for (ll j = 0; j < i.second; ++j)
{
a[++ai] = i.first; //ai初始值为0
}
}
时间复杂度为
直接得到离散化数组的实现代码：
时间复杂度为排序复杂度
copy, sort, unique 都是常用的 STL 函数。( copy 即 memcpy )

# 高级数据结构

## 数据结构作用

1，存储的空间效率eg:存储地图用nxn的二维矩阵表示，虽然速度很快，但是非常浪费空间，故应当采用更高效的数据结构，邻接表
2，访问的效率，搜索当中，先按照一定 的顺序排好序再搜索，更有效率

## 补充：三元运算符

C++中的三元运算符的语法如下：

```c++
condition ? expression1 : expression2
```

condition 是一个布尔表达式，它决定了要返回的值是 expression1 还是 expression2。
如果 condition 为真，那么三元运算符返回 expression1 的值。
如果 condition 为假，那么三元运算符返回 expression2 的值。

## 并查集

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1050;
int s[maxn+1];//用s存储每个元素的父节点s[i]=j代表着i的父节点是j
int height[maxn+1];//合并的优化时候使用
void init_set()//初始化集合，开始的时候，将父节点设置为自己
{
    for (int i =1; i <=maxn; i++)
    {
        s[i]=i;
        height[i]=0;//树的高度
    }
}
int find_Set(int x)//查找,(已经进行了路径优化)
{
    if (s[x]==x)
    {
        return x;
    }
    else//优化,eg:在查找4的时候，将4的父节点设置为1而不再是3，3的父节点设置为1，减少查询次数（并查集必须写！！！）

    {
        s[x]=find_Set(s[x]);
        return s[x];
    }
    //return x==s[x]?x:find_Set(s[x]);
}
int find_set_without_stack(int x)//上面的代码采用栈的方式实现，如果怕栈爆掉，采用以下的方式：
{
    int root =x;
    while(s[root]!=root)root=s[root];//查找根节点
    int i=x,j;
    while(i!=root)
    {
        j=s[i];//临时变量记录
        s[i]=root;//把路径上的元素的集改为根节点
        i=j;
    }
    return root;
}
void union_set(int x,int y)//合并
{
    x=find_Set(x);//找到x,y的祖先
    y=find_Set(y);
    //if(x!=y)s[x]=s[y];//    i的祖先指向j的祖先
 //合并操作的优化：将高度较小的集合合并到大的集合上，以减少树的高度，
    if(height[x]==height[y])
    {
        height[x]=height[y]+1;//合并，树的高度加一
        s[y]=x;//祖先移动
    }
    else
    {
        if(height[x]<height[y])
        {
            s[x]=y;
        }
        else
        {
            s[y]=x;
        }

    }
}
int main()
{
    int t,n,m,x,y;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        init_set();
        for (int i = 1; i <=n; i++)
        {
            cin>>x>>y;
            union_set(x,y);
        }
        
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(s[i]==i)
        ans++;
    }
    cout<<ans<<endl;
}
//合并的优化：
int height[maxn+1];
void union_set_pro(int x,int y)//合并
{
    x=find_Set(x);
    y=find_Set(y);
    if(x!=y)s[x]=s[y];
}
}
```

上述代码当中，union_set()和find_set()的搜索深度为树的长度，复杂度是O(n)，太低了！

# 差分

## WHAT

    相对于前缀和的思想，即：原数组是差分数组的前缀和
    从下标为1的数组开始，b(i)=a(i)-a(i-1)

## Where

    用于需要多从进行区间加操作，即对数组中的某个区域[l,r]内的所有数加上一个相同的值，然后查询数组上某个数或者所有数值的题目，在a区间[l,r]内均加上X，在差分数组当中将b(l)加上x而将b(r)减去X（开数组范围大点防止越界）

## 注意

    差分只能用在查询操作全部在修改操作后的情况# 分治法：
    操作思路：将问题分成k个较小规模的小问题，分别求解。

## 特征

    1，平衡子问题：子问题的规模差不多，k个，最好k=2
    2，独立子问题：子问题之间相互独立（区别于DP！！！）

## 解题步骤

    1，分解
    2，解决（递归）
    3，合并

## 应用

    归并排序，快速排序，汉诺塔
逆序对问题# 二分搜索和查找

## 二分基本

    注意这里的指针l和r，对应一个左开右闭区间[l,r)

```c++
int solve(int x)
{
        int l=1,r=n+1;
        while (l<r)//最后r和l会相等
        /*
        修改后的代码，尤其注意+1，-1的问题
        如果有多个待查找的数据并且要找到最大的数字编号
        改成：
            if(a[mid]<=x)l=mid+1;
            else r=mid;
        */
        {
            int mid=(l+(r-1))/2;
            //有时候l+r可能会超过int 类型的极限,r-1可以避免运算溢出
            if(a[mid]>=x)
            {
                r= mid;
            }
            //else if(a[mid]>x)r=mid-1;//取区间的前一半
            else l=mid+1;//取区间的后一半
        }
        if(a[l]==x)
            return l;
        else
            return -1;
}
```

## 转化的思想，转化成二分&&&STL库函数当中的运用

### 介绍STL函数

lower_bound(begin,end,val);
在有序的数组的连续地址[begin,end)找到第一个位置并且返回地址
（最后减去“这个数组”才能得到具体的位置，使得val插在这个位置前，数组依然有序）
upper_bound(begin,end,val);找到最后一个位置并且返回地址，使得val插在这个位置后

```c++
//复杂度nlogn的算法：
#include<bits/stdc++.h>
using namespace std;
/*
分析：
枚举A，那么就是要统计在数组当中B+C出现了多少次，
数列排序后B+C对应某段的左端点和右端点
*/
typedef long long ll;
ll a[200010];
ll n,c;
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    ll total=0;
    sort(a+1,a+n+1);
    for (int i = 1; i <= n; i++)
    {
        ll x =a[i]+c;
        total+=((upper_bound(a+1,a+n+1,x)-a)-(lower_bound(a+1,a+n+1,x)-a));
    }
    cout<<total;
    //cin>>n;
}
//改进版本：
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    ll total=0;
    sort(a+1,a+n+1);
    for(int i=0,L=0,R=0;i<n;i++)
    {
        //两个指针的移动次数不超过n
        while(L<n&&a[L]<a[i]+c)
        {
            L++;//L相当于lower_bound，第一个a[L]>=a[i]+c的位置
        }
        while (R<n&&a[R]<=a[i]+c)
        {
            R++;//R相当于upper_bound，第一个a[R]>a[i]+c的位置
        }
        total+=R+L;
    }
    cout<<total;
}
```

## 二分答案

    单调性判定问题
另外的一种二分代码写法，不必考虑+1和-1的问题！：
只需要想清楚程序当中的答案是否需要更新（是否要记下ans)
并且要想清楚可能的答案在哪一册（改L还是R即可）

```c++
int Find(int L,int R)//使用前确保答案在[L,R]内//注意，开始的L=0，数组从第1位开始放数字捏
{
    int ans,mid;
    while(L<=R)//闭区间上的二分条件
    {
        int mid=L+R>>1;
        if(P(mid))//条件成立
            ans=mid;R=mid-1;
            //只需要记录满足条件的mid，最后循环一定会结束，也一定会在ans当中保留正确的答案
        else 
            L=mid+1;//L和R不用考虑+1和-1，全部写上去
    }
    return ans;
}

```

### 使用二分条件技巧的条件

1，命题可以归纳成为找到使得命题P(x)成立/不成立的最大/最小的x
2，将P(x)看做一个真或者假的函数，那么它一定在某个分界线的一侧全为真，另一侧全为假
3，可以找到一个复杂度优秀的算法检验P(x)的真假

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m;
ll trees[1000005];
/*
分析，固然可以从1m往上一直枚举，但是复杂度是n×h太慢了
判断单调性：
当x超过某个数的时候，条件一定是不成立的，而当不超过这个数的时候，条件一定成立
完全符合二分条件！
*/
bool P(int h)
{
    ll total=0;
    for (int i = 0; i < n; i++)
    {
        if(trees[i]>h)
        {
            total+=trees[i]-h;
        }
    }
    return total>=m;
}
int main()
{
    cin>>n>>m;
    for (int i = 0; i < n; i++)
    {
            cin>>trees[i];
    }
    sort(trees,trees+n);
    int L=0,R=1e9,ans,mid;
    while (L<=R)
    {
        if(P(mid=L+R>>1))
            ans=mid,L=mid+1;
            //为真，mid可以成为答案，真正的答案可能在mid的右侧，左端点右移动
        else R=mid-1;//答案在mid的左侧，右端点左移
    }
    cout<<ans; 
}
```

使用二分法求解一元三次方程
精度问题：题目要求保留两位小数，那么可以在二分端点相差不超过le-4停止二分以确保精确度

```c++
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d;
#define  eps 1e-4//
double f(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    cin>>a>>b>>c>>d;
    //fabs:这个函数接受一个 double 类型的参数 x，并返回其绝对值
    for (int i = -100; i <=100; i++)
    {
        double L=i,R=i+1,mid;
        if(fabs(f(L))<eps)//L可以是根
        {
            printf("%.21f",L);
        }
        else if(fabs(f(R))<eps)//L可以是根
        {
            //printf("%.21f",R);
            continue;//跳过//等下一个循环当中L变到R了在输出，避免重复输出
        }
        else if(f(L)*f(R)<0)//在（L,R）上有根，则执行二分
        {
            while(R-L<eps)//在二分端点相差不超过10负四次方停止二分保持精度
            {
                mid=(R+L)/2;
                if(f(mid)*f(R)>0) R=mid;
                //mid和R的正负形是相同的，说明零点在mid的左侧
                else L=mid;//否则就是在另一侧
            }
            printf("%.21f",L);
        }
    }
    
}

```

## 二分法模板的应用

*** 12:6:
    建议使用上面给出的模板

```c++
#include<bits/stdc++.h>
using namespace std;
double n,m,k,l,r;
bool pd(double x){//判断当前答案是否满足 
 return (pow(1.0/(1.0+x),k)>=1-n/m*x);//pow函数，上文已讲
}
int main(){
 cin>>n>>m>>k;
    ///////////////////////二分模板
 l=0;r=10;//月利率可能大于1
 while(r-l>=0.0001){//注意精度问题 
  double mid=(l+r)/2;
  if(pd(mid))r=mid;
  else l=mid;
 }
    ///////////////////////
 cout<<fixed<<setprecision(1)<<l*100;//输出一位小数哦 
    cin>>n;
 return 0;
} 
```

# 二叉搜索树（BST）

## 特征

    1，每个元素唯一的键值，一般放在树的结点上
    2，任意一个结点的键值，比其左子树的结点的键值要大，比其所有右节点的键值小。
    3，用中序遍历可以获得二叉搜索树的有序排列
    4，插入删除操作详见以前的笔记

## 算法的区别

    区别在于用什么方法动态调整使得树是平衡的

# Treap树

    Treap可以翻译成树堆
    二叉搜索树的结点本身有个键值，除此之外，Treap树为每个节点人为地添加了1个被称为优先级的键值
    对于键值而言，树是排列二叉树；对于优先级而言，树是一个堆
    建树的过程详见P73
    
    如何给优先级？随机赋值，虽然不能保证每次生成的Treap树是一样的，但能保证插入，删除，查找的时间复杂度都是log2n的

## 树的插入&建树

    按照优先级排序，然后按照优先级从高到低的顺序插入即可

### 对上述方法的优化

每读入一个新节点，为它随机分配一个优先级，插入树当中，再动态调整树的结构
    过程：
    1，将节点按照键值先插入到合适的子树上。
    2，给节点随机分配一个优先级，如果节点的优先级违反了堆的性质，那么让节点往上走，代替父节点，形成新的树
    3,子树的优先级比父节点高=>左旋

```c++
//上述过程的调整技巧：旋转，其中son[0]是左儿子，son[1]是右儿子
void rotate(Node* &o,int d )//d=0,左旋转；d=1，右旋转
{
    Node *k=o->son[1-d];//[1-d]可以用[d^1]优化，更快
    /*这一行创建了一个指针 k，它指向节点 o 的子节点中的一个。
    子节点的选择基于 d 的值：如果 d 为 0，则 k 指向 o 的右子节点；
    如果 d 为 1，则 k 指向 o 的左子节点。这是旋转操作的关键之一，将子节点提升为新的根节点。
    */
    o->son[d^1]=k->son[d];
    /*
    这一行将节点 o 的特定子节点设置为节点 k 的特定子节点
    。d^1 是异或操作的结果，用于切换 d 的值。这行代码实现了将节点 k 的相应子节点移动到节点 o 的特定位置，
    以保证旋转的正确性。
    */
    k->son[d]=o;
    //这一行将节点 k 的特定子节点设置为节点 o，完成了旋转操作的另一部分。
    o=k;
    //最后，这行代码将节点 o 更新为节点 k，实际上将二叉树中的根节点更改为新的节点 k。
}
```

## 树的删除

    1，节点x是叶子节点=>直接删除
    2，待删除的节点X有两个子节点，找到优先级最大的子节点，将X向相反的方向旋转（向树的下层调整）知道到达了叶子节点，再直接删除

## 应用：Treap树和名次树的问题

    少林寺和尚问题：先对老和尚的等级进行排序，在加入一个新和尚的时候，找到等级最接近的老和尚，输出老和尚的id
    两种解法：map和treap树# C++学习：

## 主函数

    除了int main()以外也可以写成signed main()或者int32 main()是一样的意思，一方如果需要把全文的int替换成long long

## 输入输出流

cin>>变量名，这个表达式本身会返回一个布尔值，表示当前是否读到了EOF，为false则表示遇到了EOF

```c++
#include <bits/stdc++.h>
using namespace std;
int v, sum;
signed main()
{
while (cin >> v)
{ //类比EOF!=scanf("%d",&v)
sum += v;
}
cout << sum;
return 0;
}
```

读写加速：
使用了读写加速后，不能同时使用 cin,scanf 与 cout,printf ，否则可能出错

```c++
ios::sync_with_stdio(false);//false即0,是C++的布尔值bool类型
cin.tie(0); //0即空指针，可以写成C++的nullptr或C语言的NULL
cout.tie(0);
```

## 传引用

使用 变量类型& 传引用变量名 定义一个传引用变量(称为左值传引用)。
赋值一个传引用变量，直接把变量赋给它即可，即 传引用变量名 = 被引用变量名 。声明时必须赋值，且不能改变初始化再指向其他对象。
传引用可以视作一个变量的别名。即调用传引用等效于调用被引用变量本身。如：

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
int x = 114515;
int &y = x;
--y;
printf("%d %d", y, x);//都是114514
return 0;
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
void myswap(int &x, int &y)
{
int t = x;
x = y;
y = t;
}
int main()
{
int a = 233, b = 666;
myswap(a, b);
cout << a << ' ' << b; // 666 233
return 0;
}
```

传引用的功能是代替指针。特别注意不能传引用一个数组。
使用传引用的目的：
修改值
对很大的数据对象(结构体)，提高运行速度，避免拷贝
对于认为不需要修改值的用途里，可以写成 const 类型& 变量 。这在重载比较函数里很常用。

## 重载运算符

多维数组适合开普通的数组

```c++
返回值 operator 运算符(左参数, 右参数)
{
函数体
}
```

## sort函数

需要逆序即使用 greater<类型>() 即可获得该函数变量。
升序同理 less<类型>() 。如上述代码改为：

```c++
sort(a, a + 3, greater<int>());
```

## for-each 函数

```c++
//for-each:
    int x[5]={2,3,4,5,6};
    for(int v:x)//可以用这个来简单的输出一个vector的元素
    {
        cout<<v<<endl;
    }
    vector<int> a={2,3,4,5,6};
    for(int x:a)
    {
        cout<<x<<endl;
    }
```

## 匿名函数

```c++
    auto f=[](int a ,int b){return a+b;};//匿名函数
```

## 保留小数

要输出特定位小数，如保留小数点后九位，则使用

```c++
cout<<fixed<<setprecision(9)<<x；
```

# 深度搜索基本模板

```c++
int search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```

# DP算法  

    简单解释：多阶段决策问题，将一个复杂的问题分解成相对简单的子问题，
    这些子问题前后相关，非常相似，处理方法几乎一样。
    将前问题的计算结果记录为“状态”，存储在“状态表”当中，后面的子问题查询状态表得知前面问题的答案，减少复杂度

## 一般思路

    1，穷举法、暴力搜索穷举答案，画出递归树，尝试采用递归来进行求解
    2，如果发现存在大量的重复计算，记忆化搜索（哈希表缓存），遍历到相同的节点就直接查表
    3, 将计算的过程表示出来，观察计算的公式求解的顺序 ，尝试将递归形成改写成迭代形式（例如：两个for循环） 

## 区别于分治法

    DP之间的问题是相关的，前面问题的解决结果可以被后面的子问题利用

## 适用

    有重叠子问题和最优子结构性质的问题

## 步骤

    1，定义状态
    2，状态转移
    3，算法实现

## 核心：状态、状态转移方程

    用状态转移方程求解状态，状态往往就是问题的解

## 分类

### 线性dp

    顺推和逆推，常用“表格”来处理状态，清晰地演示推导过程

### 非线性dp

    eg:树形dp
    两个方向：
        1，根->叶，传递有用的信息给子节点，最后根得出最优解
        2，叶->根，根的子节点传递有用的信息给根，最后根得最优解

# 基础dp

## 7.1.1硬币问题

### 最少硬币个数问题

```c++
#include<bits/stdc++.h>
using namespace std;
//最少硬币问题
const int MONEY=251;//最多金额
const int VALUE=5;//5种面值
int type[VALUE]={1,5,10,25,50};
int Min[MONEY];//每个金额对应的最少的硬币数量
void solve()
{
    for(int k=0;k<MONEY;k++)
        Min[k]=INT_MAX;
    Min[0]=0;
    for(int j=0;j<VALUE;j++)
        for(int i=type[j];i<MONEY;i++)
            Min[i]=min(Min[i],Min[i-type[j]]+1);
}//不断“优化”最优解，1个，5个，10个，25个...
int main()//打表的思路
{
    int s;
    solve();
    while(cin>>s)
    {
        cout<<Min[s]<<endl;
    }
    return 0;
}
```

### 打印最少硬币的组合

```c++
#include<bits/stdc++.h>
using namespace std;
//打印最少硬币的组合：要增加一个记录表Min_path[i]记录金额i所需的最后一个硬币，利用这个数组倒推就能得到所有的硬币

const int MONEY=251;//最多金额
const int VALUE=5;//5种面值
int type[VALUE]={1,5,10,25,50};
int Min[MONEY];//每个金额对应的最少的硬币数量
int Min_path[MONEY]={0};//记录最小硬币的路径
void solve()
{
    for(int k=0;k<MONEY;k++)
        Min[k]=INT_MAX;
    Min[0]=0;
    for(int j=0;j<VALUE;j++)
        for(int i=type[j];i<MONEY;i++)
            if(Min[i]>Min[i-type[j]]+1)
            {
                Min_path[i]=type[i];//在每个金额上记录路径，即某个硬币的面值
                Min[i]=min(Min[i],Min[i-type[j]]+1);
            }
}//不断“优化”最优解，1个，5个，10个，25个...
void print_ans(int *Min_path,int s )
{
    while(s)
    {
        cout<<Min_path[s]<<" ";
        s=s-Min_path[s];
    }
}
int main()//打表的思路
{
    int s;
    solve();
    while(cin>>s)
    {
        cout<<Min[s]<<endl;
    }
    return 0;
}
```

# Treap树的实现（题目：shaolin）

```c++
#include<map>
#include<vector>
#include<iostream>
using namespace std;
//Treap树代码
int id[5000000 + 5];
struct Node
{
 int size;//以这个节点为根的子树的节点总数量，用于名次树
 int rank;//优先级
 int key;//键值
 Node* son[2];//0是左儿子，1是右儿子
 bool operator <(const Node& a)const { return rank < a.rank; }
 int cmp(int x)const//const修饰符在成员函数声明中表示该成员函数不会修改类的数据成员。
  //它可以用于对于只读操作或不修改对象状态的操作进行标记，以增加代码的清晰性和安全性。
 {
  if (x == key)return -1;
  if (x < key)
  {
   return 0;
  }
  else
   return 1;
 }
 void update()//更新size
 {
  size = 1;
  if (son[0] != NULL)size += son[0]->size;
  if (son[1] != NULL)size += son[0]->size;
 }
};
void rotate(Node*& o, int d)//d=0:左旋；d=1:右旋
{
 Node* k = o->son[d ^ 1];//位操作优化性能
 o->son[d ^ 1] = k->son[d];
 k->son[d] = o;
 o->update();
 k->update(); o = k;
}
void insert(Node*& o, int x)//将x插入到树当中
{
 if (o == NULL)
 {
  o = new Node();
  o->son[0] = o->son[1] = NULL;
  o->rank = rand();
  o->key = x;
  o->size = 1;
 }
 else
 {
  int d = o->cmp(x);//如果cmp返回-1，访问son的-1下标，不会报错吗（下标由0开始）？
  insert(o->son[d], x);
  o->update();
  if (o < o->son[d])
   rotate(o, d ^ 1);
 }
}
int kth(Node* o, int k)//找第k大的数
{
 ////如果当前节点 o 为空，或者 k 不在合法范围内（小于等于0或大于树的大小），则返回 -1。
 if (o == NULL || k <= 0 || k > o->size)
  return -1;
 //如果不满足上述条件，它首先计算右子树的大小 s（如果右子树为空则为0）
 int s = o->son[1] == NULL ? 0 : o->son[1]->size;
 //然后它与 k 比较，如果 k 等于 s + 1，则表示当前节点 o 就是第k大的数，返回 o->key。
 if (k = s + 1)return o->key;
 //如果 k 小于等于 s，则说明第k大的数在右子树中，递归地在右子树 o->son[1] 中查找第k大的数。
 else if (k <= s)return kth(o->son[1], k);
 //否则，第k大的数在左子树中，递归地在左子树 o->son[0] 中查找第 k - s - 1 大的数。
 else return kth(o->son[0], k - s - 1);
}
int find(Node* o, int k)//返回元素k的名次
{//如果当前节点 o 为空，说明没有找到元素 k，返回 -1
 if (o==NULL)
 {
  return -1;
 }
 //首先，它使用 o->cmp(k) 函数来比较元素 k 和当前节点的值，得到比较结果 d。
 // 如果 d 等于 -1，表示元素 k 等于当前节点值，返回右子树的大小加1（如果右子树为空则为1），
 // 表示当前节点是第 k 大的数。
 int d = o->cmp(k);
 if (d == -1)
  return o->son[1] == NULL ? 1 : o->son[1]->size + 1;
 //如果 d 等于 1，表示元素 k 大于当前节点值，递归地在右子树 o->son[1] 中查找元素 k。
 else if (d == 1)return find(o->son[d], k);
 //否则，d 等于 0，表示元素 k 小于当前节点值，它递归地在左子树 o->son[0] 中查找元素 k。
 else
 {
  //如果在左子树中找到了元素 k，它将返回 tmp + 1 + o->son[1]->size，其中 tmp 是元素 k 在左子树中的名次
  // o->son[1]->size 是右子树的大小，因此返回的是整个树中元素 k 的名次。
  int tmp = find(o->son[d], k);
  if (tmp == -1)
  {
   return -1;
  }
  else
   return o->son[1] == NULL ? tmp + 1 : tmp + 1 + o->son[1]->size;
 }
}


int main()
{
 int n;
 while (~scanf("%d", &n) && n)
 {
  srand(time(NULL));//time(NULL)返回当前的时间（自 1970 年 1 月 1 日以来经过的秒数）。srand函数是用来设置随机数发生器的种子，
  //它需要一个整数作为种子。种子的选择会影响随机数生成的序列。通常情况下，我们希望每次程序运行时生成的随机数序列都是不同的，而不是每次都产生相同的序列。
  //因此，srand(time(NULL)) 的作用是使用当前时间作为种子，以确保每次程序运行时都会产生不同的随机数序列。这样做可以增加随机性，
  //使得每次运行程序时得到的随机数序列都是不同的。通常这是在需要产生伪随机数的程序中使用的常见技巧。
  int k, g;
  scanf("%d%d", &k, &g);
  //创建一个新的二叉搜索树节点 root，并初始化其属性，包括左右子树为 NULL，随机排名 
  //rank，关键字 key 为 g，以及大小 size 为 1。同时，将 id[g] 赋值为 k。
  Node* root = new Node();
  root->son[0] = root->son[1] = NULL;
  root->rank = rand(); root->key = g; root->size = 1;
  id[g] = k;
  //表示当前输入的 k 和相应的排名为 1。
  printf("%d%d\n", k, 1);
  for (int i = 2; i <= n; i++)
  {
   scanf("%d%d", &k, &g);
   id[g] = k;
   //调用 insert(root, g) 将新的关键字 g 插入二叉搜索树。
   insert(root, g);
   //调用 find(root, g) 获取关键字 g 在二叉搜索树中的名次，保存在变量 t 中。
   int t = find(root, g);
   //调用 kth(root, t - 1) 和 kth(root, t + 1) 获取第 t - 1 和第 t + 1 大的数，分别保存在变量 ans1 和 ans2 中。
   int ans1, ans2, ans;
   ans1 = kth(root, t - 1);//找比t-1大的数
   ans2 = kth(root, t + 1);
   //根据一定的条件判断，更新 ans 的值，最后输出格式化的结果 printf("%d%d\n", k, id[ans])，
   // 表示当前输入的 k 和关键字 ans 对应的名次。
   //这是一个条件判断语句。它首先检查变量 ans 是否不等于 -1（即之前没有找到有效的 ans），
   // 并且 ans2 也不等于 -1。
   if (ans != -1 && ans2 != -1)
    //如果两者都满足条件，说明 ans 和 ans2 都有效，可以比较它们的差值，然后根据差值的大小来决定选择哪一个作为新的 ans。
    // 如果 ans1 - g 和 g - ans2 相等，那么选择 ans2，否则选择差值更小的那个。
    ans = ans1 - g >= g - ans2 ? ans2 : ans1;
   //如果上述条件不成立，那么检查 ans 是否等于 -1。如果等于 -1，说明之前没有有效的 ans，此时直接将 ans2 赋值给 ans。
   else if (ans == -1)ans = ans2;
   //如果前两个条件都不满足，那么说明 ans 和 ans2 都是有效的，但是它们的差值比较大。此时，直接将 ans1 赋值给 ans。
   else ans = ans1;
   printf("%d%d\n", k, id[ans]);
  }

 }

}

```

# 计数排序

太大了：map离散化

# 归并排序

分治的思想
可以求逆序对

# STL库

lower_bound();//只能在有序的数组，要想获得下标要减去数组头

# 差分和前缀和

差分：降低复杂度，与前缀和一样的
eg:区间上的数都+1

# 二分

    int mid=l+r+1>>1;//上取整找中点：>>1等同于除以二# C++学习：

## 主函数

    除了int main()以外也可以写成signed main()或者int32 main()是一样的意思，一方如果需要把全文的int替换成long long

## 输入输出流

cin>>变量名，这个表达式本身会返回一个布尔值，表示当前是否读到了EOF，为false则表示遇到了EOF

```c++
#include <bits/stdc++.h>
using namespace std;
int v, sum;
signed main()
{
while (cin >> v)
{ //类比EOF!=scanf("%d",&v)
sum += v;
}
cout << sum;
return 0;
}
```

读写加速：
使用了读写加速后，不能同时使用 cin,scanf 与 cout,printf ，否则可能出错

```c++
ios::sync_with_stdio(false);//false即0,是C++的布尔值bool类型
cin.tie(0); //0即空指针，可以写成C++的nullptr或C语言的NULL
cout.tie(0);
```

## 传引用

使用 变量类型& 传引用变量名 定义一个传引用变量(称为左值传引用)。
赋值一个传引用变量，直接把变量赋给它即可，即 传引用变量名 = 被引用变量名 。声明时必须赋值，且不能改变初始化再指向其他对象。
传引用可以视作一个变量的别名。即调用传引用等效于调用被引用变量本身。如：

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
int x = 114515;
int &y = x;
--y;
printf("%d %d", y, x);//都是114514
return 0;
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
void myswap(int &x, int &y)
{
int t = x;
x = y;
y = t;
}
int main()
{
int a = 233, b = 666;
myswap(a, b);
cout << a << ' ' << b; // 666 233
return 0;
}
```

传引用的功能是代替指针。特别注意不能传引用一个数组。
使用传引用的目的：
修改值
对很大的数据对象(结构体)，提高运行速度，避免拷贝
对于认为不需要修改值的用途里，可以写成 const 类型& 变量 。这在重载比较函数里很常用。

## 重载运算符

多维数组适合开普通的数组

```c++
返回值 operator 运算符(左参数, 右参数)
{
函数体
}
```

## sort函数

需要逆序即使用 greater<类型>() 即可获得该函数变量。
升序同理 less<类型>() 。如上述代码改为：

```c++
sort(a, a + 3, greater<int>());
```

## for-each 函数

```c++
//for-each:
    int x[5]={2,3,4,5,6};
    for(int v:x)//可以用这个来简单的输出一个vector的元素
    {
        cout<<v<<endl;
    }
    vector<int> a={2,3,4,5,6};
    for(int x:a)
    {
        cout<<x<<endl;
    }
```

## 匿名函数

```c++
    auto f=[](int a ,int b){return a+b;};//匿名函数
```

## 保留小数

要输出特定位小数，如保留小数点后九位，则使用

```c++
cout<<fixed<<setprecision(9)<<x；
```

# 深度搜索基本模板

```c++
int search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```

# STL技术

```c++
# include <bits/stdc++.h>
# include <stack>
# include <algorithm>
using namespace std;
const int MAXN = 10;
// 数组的使用：
/*
对于竞赛而言，能使用静态数组则静态数组，空间紧张可以用STL开动态，节约空间，不易出错
*/
vector<int> a(100);                   // 定义100个值为0的元素
vector<string> b(100, "null");        // 十个值为null的元素
vector<string> c(b.begin(), b.end()); // c是b的复制
vector<int> d[MAXN];                  // 定义一个二维数组，它的一维大小是固定的MAXN，二维动态（实现图的邻接表存储）
// vector的索引在常数级别，但是插入和删除速度很慢（要复制内存块）所以少用

// stack的使用：
stack<int> a_stack;

// 队列和queue:
queue<int> q;

// 优先队列priority_queue:
priority_queue<int> pq;
// 优先级别高的元素先出列
// 可以排序，复杂度：nlog2n

// 链表和list:
// list：双向链表，高效地删除和插入
list<int> l;
list<int>::iterator it;

// set集合
// 使用二叉搜索树实现，元素只出现一次，并且是排好序的，
//访问的时间复杂度是log2n
set<int> s;

// map
// map可以实现快速查照，复杂度log2n
map<string, int> m;

// 函数的声明：
void soilder();
int main()
{

    soilder();
    int a = 0;
    cin >> a;
}

// 士兵报数问题：
void soilder()
{
    int t, n;
    cin >> t;
    int k = 3;
    while (t--)
    {
        cin >> n;
        list<int> l_soilder;
        list<int>::iterator it;
        for (int i = 1; i <= n; i++)
            l_soilder.push_back(i);
        while (l_soilder.size() > 3)
        {
            int num = 1;
            if (k == 3)
                k = 2;
            if (k == 2)
                k = 3;
            for (it = l_soilder.begin(); it != l_soilder.end();)
            {
                num++;
                if (num % k == 0)
                {
                    it = l_soilder.erase(it); // 删除后it也会++
                }
                else
                {
                    it++;
                }
            }
        }
        for (it = l_soilder.begin(); it != l_soilder.end(); it++)
        {
            cout << *it;
            cout << " ";
        }
        cout << endl;
    }
}
// 约瑟夫问题
void Table()
{
    vector<int> table;
    int n, m;
    while (cin >> n >> m)
    {
        table.clear(); // 清空上次的数据
        for (int i = 0; i < 2* n; i++)
        {
            table.push_back(i);
        }
        int pos = 0; // 记录下标元素
        for (int i = 0; i < n; i++)
        {
            // 赶走n个人
            pos = (pos + m - 1) % table.size(); // 因为从当前下标开始数起，并且为了不超过，所以进行取余操作
            table.erase(table.begin() + pos);   // 赶走坏人，长度-1
            // 此次的erase执行的速度较慢，少用！
        }
        for (int i = 0, j = 0; i < 2 * n; i++)
        {
            if (j < table.size() && i == table[i]) // 剩下来的都是好人
            {
                j++;
                cout << "G";
            }
            else
            {
                cout << "B";
            }
        }
        cout << endl;
    }
}
```

# 子集枚举

子集的情况可以使用二进制来表示

## 几种集合的表示情况

    1，表示仅包含第i个元素的集合的二进制表示成：1<<(i-1)
    2,所有元素的全级：
    (1<<n)-1
    3，空集为0

## 集合的常用关系

    1，并集：A1是A2和A3的并集，则A1的每一位是A2和A3的结果，则按位或运算：a1=a2|a3
    2，交集：同上，两个子集进行与操作：a1=a2&a3
    3，包含：判断A2所有元素在A1上是否有：(a1|a2==a1)&&(a1&a2==a2)
    4，属于：（包含的特殊情况）检查某元素是否在一个集合当中：采用左位移运算符构造出那个仅含一项的集合，然后再和原集合取交，若不为空集，则真命题，eg:判断第i个元素是否属于A1：1<<(i-1)&a1
    5，补集：a^a2

## 子集问题当中常用的库函数

    __builtin_popcount():它能直接返回一个数二进制下1的个数

## 好用的函数

    1，有一个集合S，当中有n个元素，想判断第i个数是否在S当中：

```c++
bool isElementInSubset(int subset, int i) {
    // 使用位运算检查第i位是否为1
    return (subset & (1 << i)) != 0;
}
//使用了位运算来检查给定的整数 subset 中的第 i 位是否为1。
/*
左移运算 (<<)： 左移运算符将一个二进制数的所有位向左移动指定的位数。例如，1 << i 表示将1左移 i 位。在二进制中，这就等同于在右侧添加 i 个零。

例子：如果 i 是2，那么 1 << i 就是二进制的 100。

按位与运算 (&)： 按位与运算符对两个二进制数的每一位执行与操作。只有当两个相应的位都为1时，结果的相应位才为1。
例如，假设 subset 的二进制表示是 0010010，而 i 是2。在这种情况下， (1 << i) 就是 00000100。按位与运算后的结果是 00000100，这不等于零，因此 isElementInSubset 返回 true，表示 subset 中的第 i 位为1。
*/
```# 贪心法：
    删数问题：用到string 的earse(i,j)函数
```c++
        //思路：找高峰期
    int s,i;
    cin>>n>>s;
    while(s)
    {
        for(i=0;n[i]<=n[i+1];)//找到了1个高峰辽
        {
            i++;
        }
        n.erase(i,1);//删除函数，从第i个位置删除1个
        s--;
    }
    while(n[0]=='0'&&n.size()>1)
    {
        //处理前导0，如果长度是1就不能删啦
        n.erase(0,1);
    }
```

## 哈夫曼编码

    二叉树编码
    1，每个二叉树的分支，左0右1，叶子的末端是编码，可以保证前缀不包含的要求
    2，出现频次最高的字符，放在靠近根节点上，最短，频次低的字符则在最长的地方
    3，整个二叉树由底端（出现低）向顶端构建，父节点的值是子节点的值的和

```c++
//Work By:优先队列：poj1521
#include<bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    priority_queue<int,vector<int>,greater<int>> Q;//优先队列，最小的在队首
    while(getline(cin,s)&&s!="END")//输入字符
    {
        int t=1;
        sort(s.begin(),s.end());//字典序排序
        for(int i=1;i<s.length();i++)
        {
            if(s[i]!=s[i-1])
            {
                Q.push(t);
                t=1;
            }
            else 
                t++;
        }
        Q.push(t);
        int ans=0;
        while(Q.size()>1)
        {
            int a=Q.top();Q.pop();
            int b=Q.top();Q.pop();//提取队列当中最小的两个
            Q.push(a+b);
            ans+=a+b;//直接计算编码的长度即可
        }
        Q.pop();
    }
}
```

## 模拟退火（紫、蓝专题）# 前缀和

## What

    一种预处理，可简单理解成[数列的前n项之和]，可大大降低查询的时间复杂度
    个人理解：用于求某个特定区间的和
    前缀和：sum[i]=a[1]+a[2]+...+a[i];
    递推公式：sum[i]=sum[i-1]+a[i]

## 注意

    数组的下标从1开始，因为递推公式的原图，需将前缀和数组初始化为0或仅将sum[0]初始化为0

## eg

    求a[3]+a[4]+...+a[57]:
    等于S[57]-(a[1]+a[2])S为求和函数
    即：sum[57]-sum[3-1]
    原本O(r-l)的复杂度被压缩成O(1)

## 扩展：高维前缀和

# 离散化
标准定义：离散化 (discretization) 是把无限空间中有限的个体映射到有限的空间中去。
一种离散化的实现：把绝对大小转化为相对大小。
当值域跨度很大，而真实不同的取值个数很少时，可以用离散化的方法把值域调整为取值个数。
离散化+计数排序的实现：借助 。
定义 ， 表示 出现了多少次。
得到排序后原数组的实现代码：
考虑到 自带的复杂度，时间复杂度为
也可以用 ，下同。
得到排序后离散化数组的实现代码：
for (int i = 1; i <= n; ++i)
{
++cnt[a[i]];
}
for (int i = 1, s = 0; i <= k; ++i)
{
s += cnt[i];
cnt[i] = s - cnt[i];
}
for (ll i = 1; i <= n; ++i) //倒着也行
{
b[++cnt[a[i]]] = a[i];
}
for (ll i = 1; i <= n; ++i)
{
h[a[i]]++; //h是map<ll, ll>
}
for (auto i : h)
{
for (ll j = 0; j < i.second; ++j)
{
a[++ai] = i.first; //ai初始值为0
}
}
时间复杂度为
直接得到离散化数组的实现代码：
时间复杂度为排序复杂度
copy, sort, unique 都是常用的 STL 函数。( copy 即 memcpy )

# 高级数据结构

## 数据结构作用

1，存储的空间效率eg:存储地图用nxn的二维矩阵表示，虽然速度很快，但是非常浪费空间，故应当采用更高效的数据结构，邻接表
2，访问的效率，搜索当中，先按照一定 的顺序排好序再搜索，更有效率

## 补充：三元运算符

C++中的三元运算符的语法如下：

```c++
condition ? expression1 : expression2
```

condition 是一个布尔表达式，它决定了要返回的值是 expression1 还是 expression2。
如果 condition 为真，那么三元运算符返回 expression1 的值。
如果 condition 为假，那么三元运算符返回 expression2 的值。

## 并查集

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1050;
int s[maxn+1];//用s存储每个元素的父节点s[i]=j代表着i的父节点是j
int height[maxn+1];//合并的优化时候使用
void init_set()//初始化集合，开始的时候，将父节点设置为自己
{
    for (int i =1; i <=maxn; i++)
    {
        s[i]=i;
        height[i]=0;//树的高度
    }
}
int find_Set(int x)//查找,(已经进行了路径优化)
{
    if (s[x]==x)
    {
        return x;
    }
    else//优化,eg:在查找4的时候，将4的父节点设置为1而不再是3，3的父节点设置为1，减少查询次数（并查集必须写！！！）

    {
        s[x]=find_Set(s[x]);
        return s[x];
    }
    //return x==s[x]?x:find_Set(s[x]);
}
int find_set_without_stack(int x)//上面的代码采用栈的方式实现，如果怕栈爆掉，采用以下的方式：
{
    int root =x;
    while(s[root]!=root)root=s[root];//查找根节点
    int i=x,j;
    while(i!=root)
    {
        j=s[i];//临时变量记录
        s[i]=root;//把路径上的元素的集改为根节点
        i=j;
    }
    return root;
}
void union_set(int x,int y)//合并
{
    x=find_Set(x);//找到x,y的祖先
    y=find_Set(y);
    //if(x!=y)s[x]=s[y];//    i的祖先指向j的祖先
 //合并操作的优化：将高度较小的集合合并到大的集合上，以减少树的高度，
    if(height[x]==height[y])
    {
        height[x]=height[y]+1;//合并，树的高度加一
        s[y]=x;//祖先移动
    }
    else
    {
        if(height[x]<height[y])
        {
            s[x]=y;
        }
        else
        {
            s[y]=x;
        }

    }
}
int main()
{
    int t,n,m,x,y;
    cin>>t;
    while(t--)
    {
        cin>>n>>m;
        init_set();
        for (int i = 1; i <=n; i++)
        {
            cin>>x>>y;
            union_set(x,y);
        }
        
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(s[i]==i)
        ans++;
    }
    cout<<ans<<endl;
}
//合并的优化：
int height[maxn+1];
void union_set_pro(int x,int y)//合并
{
    x=find_Set(x);
    y=find_Set(y);
    if(x!=y)s[x]=s[y];
}
}
```

上述代码当中，union_set()和find_set()的搜索深度为树的长度，复杂度是O(n)，太低了！

# 差分

## WHAT

    相对于前缀和的思想，即：原数组是差分数组的前缀和
    从下标为1的数组开始，b(i)=a(i)-a(i-1)

## Where

    用于需要多从进行区间加操作，即对数组中的某个区域[l,r]内的所有数加上一个相同的值，然后查询数组上某个数或者所有数值的题目，在a区间[l,r]内均加上X，在差分数组当中将b(l)加上x而将b(r)减去X（开数组范围大点防止越界）

## 注意

    差分只能用在查询操作全部在修改操作后的情况# 分治法：
    操作思路：将问题分成k个较小规模的小问题，分别求解。

## 特征

    1，平衡子问题：子问题的规模差不多，k个，最好k=2
    2，独立子问题：子问题之间相互独立（区别于DP！！！）

## 解题步骤

    1，分解
    2，解决（递归）
    3，合并

## 应用

    归并排序，快速排序，汉诺塔
逆序对问题# 二分搜索和查找

## 二分基本

    注意这里的指针l和r，对应一个左开右闭区间[l,r)

```c++
int solve(int x)
{
        int l=1,r=n+1;
        while (l<r)//最后r和l会相等
        /*
        修改后的代码，尤其注意+1，-1的问题
        如果有多个待查找的数据并且要找到最大的数字编号
        改成：
            if(a[mid]<=x)l=mid+1;
            else r=mid;
        */
        {
            int mid=(l+(r-1))/2;
            //有时候l+r可能会超过int 类型的极限,r-1可以避免运算溢出
            if(a[mid]>=x)
            {
                r= mid;
            }
            //else if(a[mid]>x)r=mid-1;//取区间的前一半
            else l=mid+1;//取区间的后一半
        }
        if(a[l]==x)
            return l;
        else
            return -1;
}
```

## 转化的思想，转化成二分&&&STL库函数当中的运用

### 介绍STL函数

lower_bound(begin,end,val);
在有序的数组的连续地址[begin,end)找到第一个位置并且返回地址
（最后减去“这个数组”才能得到具体的位置，使得val插在这个位置前，数组依然有序）
upper_bound(begin,end,val);找到最后一个位置并且返回地址，使得val插在这个位置后

```c++
//复杂度nlogn的算法：
#include<bits/stdc++.h>
using namespace std;
/*
分析：
枚举A，那么就是要统计在数组当中B+C出现了多少次，
数列排序后B+C对应某段的左端点和右端点
*/
typedef long long ll;
ll a[200010];
ll n,c;
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    ll total=0;
    sort(a+1,a+n+1);
    for (int i = 1; i <= n; i++)
    {
        ll x =a[i]+c;
        total+=((upper_bound(a+1,a+n+1,x)-a)-(lower_bound(a+1,a+n+1,x)-a));
    }
    cout<<total;
    //cin>>n;
}
//改进版本：
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    ll total=0;
    sort(a+1,a+n+1);
    for(int i=0,L=0,R=0;i<n;i++)
    {
        //两个指针的移动次数不超过n
        while(L<n&&a[L]<a[i]+c)
        {
            L++;//L相当于lower_bound，第一个a[L]>=a[i]+c的位置
        }
        while (R<n&&a[R]<=a[i]+c)
        {
            R++;//R相当于upper_bound，第一个a[R]>a[i]+c的位置
        }
        total+=R+L;
    }
    cout<<total;
}
```

## 二分答案

    单调性判定问题
另外的一种二分代码写法，不必考虑+1和-1的问题！：
只需要想清楚程序当中的答案是否需要更新（是否要记下ans)
并且要想清楚可能的答案在哪一册（改L还是R即可）

```c++
int Find(int L,int R)//使用前确保答案在[L,R]内//注意，开始的L=0，数组从第1位开始放数字捏
{
    int ans,mid;
    while(L<=R)//闭区间上的二分条件
    {
        int mid=L+R>>1;
        if(P(mid))//条件成立
            ans=mid;R=mid-1;
            //只需要记录满足条件的mid，最后循环一定会结束，也一定会在ans当中保留正确的答案
        else 
            L=mid+1;//L和R不用考虑+1和-1，全部写上去
    }
    return ans;
}

```

### 使用二分条件技巧的条件

1，命题可以归纳成为找到使得命题P(x)成立/不成立的最大/最小的x
2，将P(x)看做一个真或者假的函数，那么它一定在某个分界线的一侧全为真，另一侧全为假
3，可以找到一个复杂度优秀的算法检验P(x)的真假

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m;
ll trees[1000005];
/*
分析，固然可以从1m往上一直枚举，但是复杂度是n×h太慢了
判断单调性：
当x超过某个数的时候，条件一定是不成立的，而当不超过这个数的时候，条件一定成立
完全符合二分条件！
*/
bool P(int h)
{
    ll total=0;
    for (int i = 0; i < n; i++)
    {
        if(trees[i]>h)
        {
            total+=trees[i]-h;
        }
    }
    return total>=m;
}
int main()
{
    cin>>n>>m;
    for (int i = 0; i < n; i++)
    {
            cin>>trees[i];
    }
    sort(trees,trees+n);
    int L=0,R=1e9,ans,mid;
    while (L<=R)
    {
        if(P(mid=L+R>>1))
            ans=mid,L=mid+1;
            //为真，mid可以成为答案，真正的答案可能在mid的右侧，左端点右移动
        else R=mid-1;//答案在mid的左侧，右端点左移
    }
    cout<<ans; 
}
```

使用二分法求解一元三次方程
精度问题：题目要求保留两位小数，那么可以在二分端点相差不超过le-4停止二分以确保精确度

```c++
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d;
#define  eps 1e-4//
double f(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    cin>>a>>b>>c>>d;
    //fabs:这个函数接受一个 double 类型的参数 x，并返回其绝对值
    for (int i = -100; i <=100; i++)
    {
        double L=i,R=i+1,mid;
        if(fabs(f(L))<eps)//L可以是根
        {
            printf("%.21f",L);
        }
        else if(fabs(f(R))<eps)//L可以是根
        {
            //printf("%.21f",R);
            continue;//跳过//等下一个循环当中L变到R了在输出，避免重复输出
        }
        else if(f(L)*f(R)<0)//在（L,R）上有根，则执行二分
        {
            while(R-L<eps)//在二分端点相差不超过10负四次方停止二分保持精度
            {
                mid=(R+L)/2;
                if(f(mid)*f(R)>0) R=mid;
                //mid和R的正负形是相同的，说明零点在mid的左侧
                else L=mid;//否则就是在另一侧
            }
            printf("%.21f",L);
        }
    }
    
}

```

## 二分法模板的应用

*** 12:6:
    建议使用上面给出的模板

```c++
#include<bits/stdc++.h>
using namespace std;
double n,m,k,l,r;
bool pd(double x){//判断当前答案是否满足 
 return (pow(1.0/(1.0+x),k)>=1-n/m*x);//pow函数，上文已讲
}
int main(){
 cin>>n>>m>>k;
    ///////////////////////二分模板
 l=0;r=10;//月利率可能大于1
 while(r-l>=0.0001){//注意精度问题 
  double mid=(l+r)/2;
  if(pd(mid))r=mid;
  else l=mid;
 }
    ///////////////////////
 cout<<fixed<<setprecision(1)<<l*100;//输出一位小数哦 
    cin>>n;
 return 0;
} 
```

# 二叉搜索树（BST）

## 特征

    1，每个元素唯一的键值，一般放在树的结点上
    2，任意一个结点的键值，比其左子树的结点的键值要大，比其所有右节点的键值小。
    3，用中序遍历可以获得二叉搜索树的有序排列
    4，插入删除操作详见以前的笔记

## 算法的区别

    区别在于用什么方法动态调整使得树是平衡的

# Treap树

    Treap可以翻译成树堆
    二叉搜索树的结点本身有个键值，除此之外，Treap树为每个节点人为地添加了1个被称为优先级的键值
    对于键值而言，树是排列二叉树；对于优先级而言，树是一个堆
    建树的过程详见P73
    
    如何给优先级？随机赋值，虽然不能保证每次生成的Treap树是一样的，但能保证插入，删除，查找的时间复杂度都是log2n的

## 树的插入&建树

    按照优先级排序，然后按照优先级从高到低的顺序插入即可

### 对上述方法的优化

每读入一个新节点，为它随机分配一个优先级，插入树当中，再动态调整树的结构
    过程：
    1，将节点按照键值先插入到合适的子树上。
    2，给节点随机分配一个优先级，如果节点的优先级违反了堆的性质，那么让节点往上走，代替父节点，形成新的树
    3,子树的优先级比父节点高=>左旋

```c++
//上述过程的调整技巧：旋转，其中son[0]是左儿子，son[1]是右儿子
void rotate(Node* &o,int d )//d=0,左旋转；d=1，右旋转
{
    Node *k=o->son[1-d];//[1-d]可以用[d^1]优化，更快
    /*这一行创建了一个指针 k，它指向节点 o 的子节点中的一个。
    子节点的选择基于 d 的值：如果 d 为 0，则 k 指向 o 的右子节点；
    如果 d 为 1，则 k 指向 o 的左子节点。这是旋转操作的关键之一，将子节点提升为新的根节点。
    */
    o->son[d^1]=k->son[d];
    /*
    这一行将节点 o 的特定子节点设置为节点 k 的特定子节点
    。d^1 是异或操作的结果，用于切换 d 的值。这行代码实现了将节点 k 的相应子节点移动到节点 o 的特定位置，
    以保证旋转的正确性。
    */
    k->son[d]=o;
    //这一行将节点 k 的特定子节点设置为节点 o，完成了旋转操作的另一部分。
    o=k;
    //最后，这行代码将节点 o 更新为节点 k，实际上将二叉树中的根节点更改为新的节点 k。
}
```

## 树的删除

    1，节点x是叶子节点=>直接删除
    2，待删除的节点X有两个子节点，找到优先级最大的子节点，将X向相反的方向旋转（向树的下层调整）知道到达了叶子节点，再直接删除

## 应用：Treap树和名次树的问题

    少林寺和尚问题：先对老和尚的等级进行排序，在加入一个新和尚的时候，找到等级最接近的老和尚，输出老和尚的id
    两种解法：map和treap树# C++学习：

## 主函数

    除了int main()以外也可以写成signed main()或者int32 main()是一样的意思，一方如果需要把全文的int替换成long long

## 输入输出流

cin>>变量名，这个表达式本身会返回一个布尔值，表示当前是否读到了EOF，为false则表示遇到了EOF

```c++
#include <bits/stdc++.h>
using namespace std;
int v, sum;
signed main()
{
while (cin >> v)
{ //类比EOF!=scanf("%d",&v)
sum += v;
}
cout << sum;
return 0;
}
```

读写加速：
使用了读写加速后，不能同时使用 cin,scanf 与 cout,printf ，否则可能出错

```c++
ios::sync_with_stdio(false);//false即0,是C++的布尔值bool类型
cin.tie(0); //0即空指针，可以写成C++的nullptr或C语言的NULL
cout.tie(0);
```

## 传引用

使用 变量类型& 传引用变量名 定义一个传引用变量(称为左值传引用)。
赋值一个传引用变量，直接把变量赋给它即可，即 传引用变量名 = 被引用变量名 。声明时必须赋值，且不能改变初始化再指向其他对象。
传引用可以视作一个变量的别名。即调用传引用等效于调用被引用变量本身。如：

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
int x = 114515;
int &y = x;
--y;
printf("%d %d", y, x);//都是114514
return 0;
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
void myswap(int &x, int &y)
{
int t = x;
x = y;
y = t;
}
int main()
{
int a = 233, b = 666;
myswap(a, b);
cout << a << ' ' << b; // 666 233
return 0;
}
```

传引用的功能是代替指针。特别注意不能传引用一个数组。
使用传引用的目的：
修改值
对很大的数据对象(结构体)，提高运行速度，避免拷贝
对于认为不需要修改值的用途里，可以写成 const 类型& 变量 。这在重载比较函数里很常用。

## 重载运算符

多维数组适合开普通的数组

```c++
返回值 operator 运算符(左参数, 右参数)
{
函数体
}
```

## sort函数

需要逆序即使用 greater<类型>() 即可获得该函数变量。
升序同理 less<类型>() 。如上述代码改为：

```c++
sort(a, a + 3, greater<int>());
```

## for-each 函数

```c++
//for-each:
    int x[5]={2,3,4,5,6};
    for(int v:x)//可以用这个来简单的输出一个vector的元素
    {
        cout<<v<<endl;
    }
    vector<int> a={2,3,4,5,6};
    for(int x:a)
    {
        cout<<x<<endl;
    }
```

## 匿名函数

```c++
    auto f=[](int a ,int b){return a+b;};//匿名函数
```

## 保留小数

要输出特定位小数，如保留小数点后九位，则使用

```c++
cout<<fixed<<setprecision(9)<<x；
```

# 深度搜索基本模板

```c++
int search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```

# DP算法  

    简单解释：多阶段决策问题，将一个复杂的问题分解成相对简单的子问题，
    这些子问题前后相关，非常相似，处理方法几乎一样。
    将前问题的计算结果记录为“状态”，存储在“状态表”当中，后面的子问题查询状态表得知前面问题的答案，减少复杂度

## 一般思路

    1，穷举法、暴力搜索穷举答案，画出递归树，尝试采用递归来进行求解
    2，如果发现存在大量的重复计算，记忆化搜索（哈希表缓存），遍历到相同的节点就直接查表
    3, 将计算的过程表示出来，观察计算的公式求解的顺序 ，尝试将递归形成改写成迭代形式（例如：两个for循环） 

## 区别于分治法

    DP之间的问题是相关的，前面问题的解决结果可以被后面的子问题利用

## 适用

    有重叠子问题和最优子结构性质的问题

## 步骤

    1，定义状态
    2，状态转移
    3，算法实现

## 核心：状态、状态转移方程

    用状态转移方程求解状态，状态往往就是问题的解

## 分类

### 线性dp

    顺推和逆推，常用“表格”来处理状态，清晰地演示推导过程

### 非线性dp

    eg:树形dp
    两个方向：
        1，根->叶，传递有用的信息给子节点，最后根得出最优解
        2，叶->根，根的子节点传递有用的信息给根，最后根得最优解

# 基础dp

## 7.1.1硬币问题

### 最少硬币个数问题

```c++
#include<bits/stdc++.h>
using namespace std;
//最少硬币问题
const int MONEY=251;//最多金额
const int VALUE=5;//5种面值
int type[VALUE]={1,5,10,25,50};
int Min[MONEY];//每个金额对应的最少的硬币数量
void solve()
{
    for(int k=0;k<MONEY;k++)
        Min[k]=INT_MAX;
    Min[0]=0;
    for(int j=0;j<VALUE;j++)
        for(int i=type[j];i<MONEY;i++)
            Min[i]=min(Min[i],Min[i-type[j]]+1);
}//不断“优化”最优解，1个，5个，10个，25个...
int main()//打表的思路
{
    int s;
    solve();
    while(cin>>s)
    {
        cout<<Min[s]<<endl;
    }
    return 0;
}
```

### 打印最少硬币的组合

```c++
#include<bits/stdc++.h>
using namespace std;
//打印最少硬币的组合：要增加一个记录表Min_path[i]记录金额i所需的最后一个硬币，利用这个数组倒推就能得到所有的硬币

const int MONEY=251;//最多金额
const int VALUE=5;//5种面值
int type[VALUE]={1,5,10,25,50};
int Min[MONEY];//每个金额对应的最少的硬币数量
int Min_path[MONEY]={0};//记录最小硬币的路径
void solve()
{
    for(int k=0;k<MONEY;k++)
        Min[k]=INT_MAX;
    Min[0]=0;
    for(int j=0;j<VALUE;j++)
        for(int i=type[j];i<MONEY;i++)
            if(Min[i]>Min[i-type[j]]+1)
            {
                Min_path[i]=type[i];//在每个金额上记录路径，即某个硬币的面值
                Min[i]=min(Min[i],Min[i-type[j]]+1);
            }
}//不断“优化”最优解，1个，5个，10个，25个...
void print_ans(int *Min_path,int s )
{
    while(s)
    {
        cout<<Min_path[s]<<" ";
        s=s-Min_path[s];
    }
}
int main()//打表的思路
{
    int s;
    solve();
    while(cin>>s)
    {
        cout<<Min[s]<<endl;
    }
    return 0;
}
```

# Treap树的实现（题目：shaolin）

```c++
#include<map>
#include<vector>
#include<iostream>
using namespace std;
//Treap树代码
int id[5000000 + 5];
struct Node
{
 int size;//以这个节点为根的子树的节点总数量，用于名次树
 int rank;//优先级
 int key;//键值
 Node* son[2];//0是左儿子，1是右儿子
 bool operator <(const Node& a)const { return rank < a.rank; }
 int cmp(int x)const//const修饰符在成员函数声明中表示该成员函数不会修改类的数据成员。
  //它可以用于对于只读操作或不修改对象状态的操作进行标记，以增加代码的清晰性和安全性。
 {
  if (x == key)return -1;
  if (x < key)
  {
   return 0;
  }
  else
   return 1;
 }
 void update()//更新size
 {
  size = 1;
  if (son[0] != NULL)size += son[0]->size;
  if (son[1] != NULL)size += son[0]->size;
 }
};
void rotate(Node*& o, int d)//d=0:左旋；d=1:右旋
{
 Node* k = o->son[d ^ 1];//位操作优化性能
 o->son[d ^ 1] = k->son[d];
 k->son[d] = o;
 o->update();
 k->update(); o = k;
}
void insert(Node*& o, int x)//将x插入到树当中
{
 if (o == NULL)
 {
  o = new Node();
  o->son[0] = o->son[1] = NULL;
  o->rank = rand();
  o->key = x;
  o->size = 1;
 }
 else
 {
  int d = o->cmp(x);//如果cmp返回-1，访问son的-1下标，不会报错吗（下标由0开始）？
  insert(o->son[d], x);
  o->update();
  if (o < o->son[d])
   rotate(o, d ^ 1);
 }
}
int kth(Node* o, int k)//找第k大的数
{
 ////如果当前节点 o 为空，或者 k 不在合法范围内（小于等于0或大于树的大小），则返回 -1。
 if (o == NULL || k <= 0 || k > o->size)
  return -1;
 //如果不满足上述条件，它首先计算右子树的大小 s（如果右子树为空则为0）
 int s = o->son[1] == NULL ? 0 : o->son[1]->size;
 //然后它与 k 比较，如果 k 等于 s + 1，则表示当前节点 o 就是第k大的数，返回 o->key。
 if (k = s + 1)return o->key;
 //如果 k 小于等于 s，则说明第k大的数在右子树中，递归地在右子树 o->son[1] 中查找第k大的数。
 else if (k <= s)return kth(o->son[1], k);
 //否则，第k大的数在左子树中，递归地在左子树 o->son[0] 中查找第 k - s - 1 大的数。
 else return kth(o->son[0], k - s - 1);
}
int find(Node* o, int k)//返回元素k的名次
{//如果当前节点 o 为空，说明没有找到元素 k，返回 -1
 if (o==NULL)
 {
  return -1;
 }
 //首先，它使用 o->cmp(k) 函数来比较元素 k 和当前节点的值，得到比较结果 d。
 // 如果 d 等于 -1，表示元素 k 等于当前节点值，返回右子树的大小加1（如果右子树为空则为1），
 // 表示当前节点是第 k 大的数。
 int d = o->cmp(k);
 if (d == -1)
  return o->son[1] == NULL ? 1 : o->son[1]->size + 1;
 //如果 d 等于 1，表示元素 k 大于当前节点值，递归地在右子树 o->son[1] 中查找元素 k。
 else if (d == 1)return find(o->son[d], k);
 //否则，d 等于 0，表示元素 k 小于当前节点值，它递归地在左子树 o->son[0] 中查找元素 k。
 else
 {
  //如果在左子树中找到了元素 k，它将返回 tmp + 1 + o->son[1]->size，其中 tmp 是元素 k 在左子树中的名次
  // o->son[1]->size 是右子树的大小，因此返回的是整个树中元素 k 的名次。
  int tmp = find(o->son[d], k);
  if (tmp == -1)
  {
   return -1;
  }
  else
   return o->son[1] == NULL ? tmp + 1 : tmp + 1 + o->son[1]->size;
 }
}


int main()
{
 int n;
 while (~scanf("%d", &n) && n)
 {
  srand(time(NULL));//time(NULL)返回当前的时间（自 1970 年 1 月 1 日以来经过的秒数）。srand函数是用来设置随机数发生器的种子，
  //它需要一个整数作为种子。种子的选择会影响随机数生成的序列。通常情况下，我们希望每次程序运行时生成的随机数序列都是不同的，而不是每次都产生相同的序列。
  //因此，srand(time(NULL)) 的作用是使用当前时间作为种子，以确保每次程序运行时都会产生不同的随机数序列。这样做可以增加随机性，
  //使得每次运行程序时得到的随机数序列都是不同的。通常这是在需要产生伪随机数的程序中使用的常见技巧。
  int k, g;
  scanf("%d%d", &k, &g);
  //创建一个新的二叉搜索树节点 root，并初始化其属性，包括左右子树为 NULL，随机排名 
  //rank，关键字 key 为 g，以及大小 size 为 1。同时，将 id[g] 赋值为 k。
  Node* root = new Node();
  root->son[0] = root->son[1] = NULL;
  root->rank = rand(); root->key = g; root->size = 1;
  id[g] = k;
  //表示当前输入的 k 和相应的排名为 1。
  printf("%d%d\n", k, 1);
  for (int i = 2; i <= n; i++)
  {
   scanf("%d%d", &k, &g);
   id[g] = k;
   //调用 insert(root, g) 将新的关键字 g 插入二叉搜索树。
   insert(root, g);
   //调用 find(root, g) 获取关键字 g 在二叉搜索树中的名次，保存在变量 t 中。
   int t = find(root, g);
   //调用 kth(root, t - 1) 和 kth(root, t + 1) 获取第 t - 1 和第 t + 1 大的数，分别保存在变量 ans1 和 ans2 中。
   int ans1, ans2, ans;
   ans1 = kth(root, t - 1);//找比t-1大的数
   ans2 = kth(root, t + 1);
   //根据一定的条件判断，更新 ans 的值，最后输出格式化的结果 printf("%d%d\n", k, id[ans])，
   // 表示当前输入的 k 和关键字 ans 对应的名次。
   //这是一个条件判断语句。它首先检查变量 ans 是否不等于 -1（即之前没有找到有效的 ans），
   // 并且 ans2 也不等于 -1。
   if (ans != -1 && ans2 != -1)
    //如果两者都满足条件，说明 ans 和 ans2 都有效，可以比较它们的差值，然后根据差值的大小来决定选择哪一个作为新的 ans。
    // 如果 ans1 - g 和 g - ans2 相等，那么选择 ans2，否则选择差值更小的那个。
    ans = ans1 - g >= g - ans2 ? ans2 : ans1;
   //如果上述条件不成立，那么检查 ans 是否等于 -1。如果等于 -1，说明之前没有有效的 ans，此时直接将 ans2 赋值给 ans。
   else if (ans == -1)ans = ans2;
   //如果前两个条件都不满足，那么说明 ans 和 ans2 都是有效的，但是它们的差值比较大。此时，直接将 ans1 赋值给 ans。
   else ans = ans1;
   printf("%d%d\n", k, id[ans]);
  }

 }

}

```

# 计数排序

太大了：map离散化

# 归并排序

分治的思想
可以求逆序对

# STL库

lower_bound();//只能在有序的数组，要想获得下标要减去数组头

# 差分和前缀和

差分：降低复杂度，与前缀和一样的
eg:区间上的数都+1

# 二分

    int mid=l+r+1>>1;//上取整找中点：>>1等同于除以二# C++学习：

## 主函数

    除了int main()以外也可以写成signed main()或者int32 main()是一样的意思，一方如果需要把全文的int替换成long long

## 输入输出流

cin>>变量名，这个表达式本身会返回一个布尔值，表示当前是否读到了EOF，为false则表示遇到了EOF

```c++
#include <bits/stdc++.h>
using namespace std;
int v, sum;
signed main()
{
while (cin >> v)
{ //类比EOF!=scanf("%d",&v)
sum += v;
}
cout << sum;
return 0;
}
```

读写加速：
使用了读写加速后，不能同时使用 cin,scanf 与 cout,printf ，否则可能出错

```c++
ios::sync_with_stdio(false);//false即0,是C++的布尔值bool类型
cin.tie(0); //0即空指针，可以写成C++的nullptr或C语言的NULL
cout.tie(0);
```

## 传引用

使用 变量类型& 传引用变量名 定义一个传引用变量(称为左值传引用)。
赋值一个传引用变量，直接把变量赋给它即可，即 传引用变量名 = 被引用变量名 。声明时必须赋值，且不能改变初始化再指向其他对象。
传引用可以视作一个变量的别名。即调用传引用等效于调用被引用变量本身。如：

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
int x = 114515;
int &y = x;
--y;
printf("%d %d", y, x);//都是114514
return 0;
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
void myswap(int &x, int &y)
{
int t = x;
x = y;
y = t;
}
int main()
{
int a = 233, b = 666;
myswap(a, b);
cout << a << ' ' << b; // 666 233
return 0;
}
```

传引用的功能是代替指针。特别注意不能传引用一个数组。
使用传引用的目的：
修改值
对很大的数据对象(结构体)，提高运行速度，避免拷贝
对于认为不需要修改值的用途里，可以写成 const 类型& 变量 。这在重载比较函数里很常用。

## 重载运算符

多维数组适合开普通的数组

```c++
返回值 operator 运算符(左参数, 右参数)
{
函数体
}
```

## sort函数

需要逆序即使用 greater<类型>() 即可获得该函数变量。
升序同理 less<类型>() 。如上述代码改为：

```c++
sort(a, a + 3, greater<int>());
```

## for-each 函数

```c++
//for-each:
    int x[5]={2,3,4,5,6};
    for(int v:x)//可以用这个来简单的输出一个vector的元素
    {
        cout<<v<<endl;
    }
    vector<int> a={2,3,4,5,6};
    for(int x:a)
    {
        cout<<x<<endl;
    }
```

## 匿名函数

```c++
    auto f=[](int a ,int b){return a+b;};//匿名函数
```

## 保留小数

要输出特定位小数，如保留小数点后九位，则使用

```c++
cout<<fixed<<setprecision(9)<<x；
```

# 深度搜索基本模板

```c++
int search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```

# STL技术

```c++
# include <bits/stdc++.h>
# include <stack>
# include <algorithm>
using namespace std;
const int MAXN = 10;
// 数组的使用：
/*
对于竞赛而言，能使用静态数组则静态数组，空间紧张可以用STL开动态，节约空间，不易出错
*/
vector<int> a(100);                   // 定义100个值为0的元素
vector<string> b(100, "null");        // 十个值为null的元素
vector<string> c(b.begin(), b.end()); // c是b的复制
vector<int> d[MAXN];                  // 定义一个二维数组，它的一维大小是固定的MAXN，二维动态（实现图的邻接表存储）
// vector的索引在常数级别，但是插入和删除速度很慢（要复制内存块）所以少用

// stack的使用：
stack<int> a_stack;

// 队列和queue:
queue<int> q;

// 优先队列priority_queue:
priority_queue<int> pq;
// 优先级别高的元素先出列
// 可以排序，复杂度：nlog2n

// 链表和list:
// list：双向链表，高效地删除和插入
list<int> l;
list<int>::iterator it;

// set集合
// 使用二叉搜索树实现，元素只出现一次，并且是排好序的，
//访问的时间复杂度是log2n
set<int> s;

// map
// map可以实现快速查照，复杂度log2n
map<string, int> m;

// 函数的声明：
void soilder();
int main()
{

    soilder();
    int a = 0;
    cin >> a;
}

// 士兵报数问题：
void soilder()
{
    int t, n;
    cin >> t;
    int k = 3;
    while (t--)
    {
        cin >> n;
        list<int> l_soilder;
        list<int>::iterator it;
        for (int i = 1; i <= n; i++)
            l_soilder.push_back(i);
        while (l_soilder.size() > 3)
        {
            int num = 1;
            if (k == 3)
                k = 2;
            if (k == 2)
                k = 3;
            for (it = l_soilder.begin(); it != l_soilder.end();)
            {
                num++;
                if (num % k == 0)
                {
                    it = l_soilder.erase(it); // 删除后it也会++
                }
                else
                {
                    it++;
                }
            }
        }
        for (it = l_soilder.begin(); it != l_soilder.end(); it++)
        {
            cout << *it;
            cout << " ";
        }
        cout << endl;
    }
}
// 约瑟夫问题
void Table()
{
    vector<int> table;
    int n, m;
    while (cin >> n >> m)
    {
        table.clear(); // 清空上次的数据
        for (int i = 0; i < 2* n; i++)
        {
            table.push_back(i);
        }
        int pos = 0; // 记录下标元素
        for (int i = 0; i < n; i++)
        {
            // 赶走n个人
            pos = (pos + m - 1) % table.size(); // 因为从当前下标开始数起，并且为了不超过，所以进行取余操作
            table.erase(table.begin() + pos);   // 赶走坏人，长度-1
            // 此次的erase执行的速度较慢，少用！
        }
        for (int i = 0, j = 0; i < 2 * n; i++)
        {
            if (j < table.size() && i == table[i]) // 剩下来的都是好人
            {
                j++;
                cout << "G";
            }
            else
            {
                cout << "B";
            }
        }
        cout << endl;
    }
}
```

# 子集枚举

子集的情况可以使用二进制来表示

## 几种集合的表示情况

    1，表示仅包含第i个元素的集合的二进制表示成：1<<(i-1)
    2,所有元素的全级：
    (1<<n)-1
    3，空集为0

## 集合的常用关�# 杂

## P1106删数问题

Tip1：思想：找最高峰，得到最小的数字
Tip2：处理前导0的技巧，删除函数的earse的技术

```c++
int main()
{
    //思路：找高峰期
    int s,i;
    cin>>n>>s;
    while(s)
    {
        for(i=0;n[i]<=n[i+1];)//找到了1个高峰辽
        {
            i++;
        }
        n.erase(i,1);//删除函数，从第i个位置删除1个
        s--;
    }
    while(n[0]=='0'&&n.size()>1)
    {
        //处理前导0，如果长度是1就不能删啦
        n.erase(0,1);
    }
    cout<<n;
}
```

# 搜索技术

    使用的算法：BFS（队列实现）DFS（递归实现）
    两种算法衍生=>A*算法、双向广搜算法、迭代加深搜索、IDA*......
## 暴力搜索常见操作：
    1，找到所有可能的数据并且用数据结构表示出来（也有难度）
    2，剪枝，减少搜索的空间
    3，用某个算法检索这些数据

## 4.1:递归与全排列
    =>需要进行全排列的题目，元素应当小于11个（否则会超时）

## 4.2:子集生成和组合问题：
    用二进制的概念表示子集是否存在最为直观eg:
    a0 a1 a2 ;a0 a1...
    1  1  1   1  1  0...
    每一个子集对应一个二进制数这个二进制数的每一个1对应着这个子集中的某个元素
    也可以推出子集的个数为2^n（表中二进制的总个数是2^n)

```c++
int main()
{
int n;
cin>>n;
print_subset(n);
cin>>n;
}
void print_subset(int n)
{
    for (int i = 0; i < (1<<n); i++)//1左移一位变成（10）即相当于2的一次方，左移n位即相当于2的n次方
    {
        for (int j = 0; j < n; j++)
        {
            if(i&(1<<j))
                cout<<j<<" ";
        }
        cout<<endl;
    }
}
```

# 递推与递归

## 递推思想

    对于一个问题，能确定初始（边界）条件，写出递推式，那么就可以考虑使用递推
    规模很大的递推任务可以使用矩阵加速
    在【过河卒】题目当中，使用递推思路比DFS远远要快

### (类)斐波那契数列

    eg:数楼梯
    设走到第i个台阶的走法是f[i],则f[100]=f[99]+f[98](要走到100首先要到98或者99然后一步)
    =>f[i]=f[i-1]+f[i-2]
    初始条件f[1]=1;f[2]=2;
    ****斐波那契的初始条件是f[1]=f[2]=1******

```python
n=int(input())
f=[0] * 5010
f[1]=1
f[2]=2
for i in range(3,n+1):
  f[i]=f[i-2]+f[i-1]
print(f[n])
```

### 栈

```cpp
// n个小球按顺序一个个入管，
// 一次可以任意个球倒出来，求倒出来的方式：
/*
分析：
    每一个球都可以是最后出管的
    设第k个球是最后出管的，比k早入且早出有k-1
    共h[k-1]种方式，比k晚入早出有n-k,共h[n-k]方式
    则这种情况下有h[k-1]*h[n-k]方式
    所以递推式：
    h(n)=h(0)*h(n-1)+h(1)*h(n-2)+...+h(n-1)*h(0)
    h[0]=h[1]=1

*/
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n, h[20] = {1, 1};
    for (int i = 2; i < n + 1; i++)
    {
        for (int j = 0; j < i; j++)
        {
            h[i] += h[j] * h[i - j - 1];
        }
    }
    cout << h[n];
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;
/*
注意到：
f[i]=f[i/2]+f[(i-1)/2]+...+f[2]+f[1]

*/
int n, t[1010];
int main()
{
    cin >> n;
    t[1] = 1, t[2] = 2, t[3] = 2, t[4] = 4, t[5] = 4, t[6] = 6;
}
int solution(int x)
{
    int ans = 0;
    for (int i = 1; i <= n; i++) // 1~n的递推
    {
        for (int j = 1; j <= i / 2; j++)
        {
            t[i] += t[j];
        }
        t[i]++;//加本身
    }
}
```

## 递归思想

### 例题：数的计算

注意：有时候搜索会超过指定长度，记得使用一个数组将结果保存下来，以后想要使用结果的时候直接查表就可以了

```cpp
#include<bits/stdc++.h>
/*
8后面加上一个元素，可以是4/3/2/1
但要加上其他的数列，怎么处理？=>
加上4/3/2/1的答案即可
原本是8的问题，现在分解成了4个子问题的问题，一直向下分解，直到得到了解为止。直到1，无法再继续分解即可
*/
int f[1010],n;
using namespace std;
int solution_vision2(int x);
int main()
{
    cin>>n;
    memset(f,-1,sizeof(f));//将f中的每一个元素的值都赋值成-1
    f[1]=1;
    int k=solution_vision2(n);
    cout<<k;
}
/*
solution不能通过问题，原因是做了很多的无效功，比如sol(2)会被sol(4)和sol(8)重复计算
所以可以定义一个数组f，当需要问题的答案是，进行查询
*/
int solution_vision2(int x)
{
    int ans=1;
    if(f[x]!=-1)
    {
        return f[x];
    }
    for (int i = 1; i <= x/2; i++)
    {
        ans+=solution_vision2(i);
    }
    return f[x]=ans;//将 ans 赋值给数组 f 的第 x 个元素，并将这个值作为函数的返回值返回。
}
int solution_vision1(int x)
{
    if (x==1)
    {
        return 1;
    }
    int ans=1;//自己本身就是一个解
    for (int i = 1; i <= x/2; i++)
    {
        ans+=solution_vision1(i);
    }
    return ans;
}
```

递推用在字符串处理的问题上：

```cpp
#include <bits/stdc++.h>
using namespace std;

string expend2();
int m;
int main()
{
    cout << expend2();
    cin >> m;
    // cout<<rezip(mima);
}
string expend2()
{
    string mima, x;
    char c;
    int times;
    while (cin >> c) // 持续读完所有的字符
    {
        if (c == '[')
        {
            cin >> times;
            x = expend2();
            while (times--)
            {
                mima += x;
            }
        }
        else if (c == ']')
        {
            return mima;
        }
        else
        {
            mima += c;
        }
    }
    return mima;
}
```

## 递推与递归

很多时候，可以递推的问题也可以用递归，相互转化。
但是，递推要求出递推顺序（多维递推，如【数的计算】），初始条件，这个时候采用递归更好捏#BFS

# 棋盘问题

学习点：1,二维数组表示上下左右方向2,

```c++
#include<bits/stdc++.h>
using namespace std;
int Wx,Wy,num;//表示有Wx行，Wy列;用num统计可走的位置有多少
char room[23][23];
struct node//表示每个节点
{
        int x;
        int y;
};
int dir[4][2]={
{-1,0},//左（左上角的坐标为（0,0）
{0,-1},//上
{1,0},//右
{0,1}};//下
int main()
{
    int x,y, dx,dy;//dx和dy表示起点的坐标
    while(cin>>Wx>>Wy)
    {
        if(Wx==0&&Wy==0)
        {
            break;
        }
        for(y=0;y<Wy;y++)
        {
            for(x=0;x<Wx;x++)
            {
                cin>>room[x][y];
                if(room[x][y]=='@')//是起点呢
                {
                    dx=x;dy=y;
                }
            }
        }
    num=0;
    BFS(dx,dy);
    cout<<num<<endl;
    }
}
bool cheack_in_room(int x,int y)
{
    return x<Wx&&x>=0&&y>=0&&y<Wy;
}
void BFS(int dx,int dy)
{
    num=1;
    queue <node> q;
    node start,next;
    start.x=dx,start.y=dy;
    q.push(start);
    while(!q.empty())
    {
        start=q.front();
        q.pop();
    }
    for (int i = 0; i < 4; i++)//按照左上右下四个方向顺时针逐一搜索
    {
        next.x=start.x+dir[i][0];
        next.y=start.y+dir[i][1];
        if(cheack_in_room(next.x,next.y)&&room[next.x][next.y]=='.')
        {
            room[next.x][next.y]=='#';
            num++;
            q.push(next);
        }
    }    
}
```

# 八皇后问题

## 八数码问题和状态图搜索
### 问题：
        8个数字在3x3的棋盘当中，移动数码使得到达目标位置
        问到达某个指定位置时，要多少步
### 分析：
        BFS，广度搜索
        但会发现需要判重，需要把新状态与9！对比，有9！*9！次检查
### 判重方法：
        康拓展开：
        Cantor()复杂度：n^2
        输入一个排列，返回它的排名，在数组当中将其置为1，从而实现排列
        公式：第X个排序的计算公式如下：
        X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[2]*1+a[0]*0!
        a[i]表示原数的第i位在当前未出现的元素当中排在第几个（0开始）

```c++
#include<bits/stdc++.h>
using namespace std;

const int LEN=362880;
struct node
{
    int state[9];//记录八数码的排列，一个状态
    int distance;//记录到起点的距离
};
int visited[LEN]={0};//原先的状态全为0
int start[9];//开始目标
int goal[9];//结束目标
long int factory[]={1,1,2,6,24,120,720,5040,40320,362880};//康拓展开需要用到的常数
int dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}};
//康托展开
bool Cantor(int str[],int n)
{
    int result=0;
    for (int i = 0; i < n; i++)
    {
        int counted=0;
        for (int j = i+1; j < n; j++)
        {
            if(str[i]>str[j])//当前未出现的元素排在第几个
                ++counted;

        }
        result+=counted*factory[n-i-1];//用数组枚举
    }
    if(!visited[result])//没有被访问过
    {
        visited[result]=1;
        return 1;
    }
    else
        return 0;
    
}
int BFS()
{
    node head;
    memcpy(head.state,start,sizeof(head.state));//复制起点的状态
    head.distance=0;
    queue<node>q;
    Cantor(head.state,9);
    q.push(head);

    while (!q.empty())
    {
        head=q.front();
        if(memcmp(head.state,goal,sizeof(goal))==0)//与目标状态对比
        {
            return head.distance;//到达目标目标，返回局里，结束
        }
        q.pop();
        int z;
        for ( z = 0; z <9; z++)
        {
            if(head.state[z]==0)
                break;
        }
        //转化为二维，左上角是原点(0,0)
        int x=z%3;//横坐标
        int y=z/3;//纵坐标
        for (int i = 0; i < 4; i++)//上下左右最多可能有4个新状态
        {
            //元素0转移后的新坐标
            int newx=x+dir[i][0];
            int newy=y+dir[i][1];
            //转化成1维
            int nz=newx+3*newy;
            if(newx>=0&&newx<3&&newy>=0&&newy<3)
            {
                node newnode;
                memcpy(&newnode,&head,sizeof(struct node));
                swap(newnode.state[z],newnode.state[nz]);//0移动到新的位置
                newnode.distance++;
                if (Cantor(newnode.state,9))
                {
                    q.push(newnode);
                }
                
            }
            
        }
        
    }
    return -1;

}

int main()
{
    for (int i = 0; i < 9; i++)
    {
        cin>>start[i];
    }
    for (int i = 0; i < 9; i++)
    {
        cin>>goal[i];
    }
    int num=BFS();
    if(num!=1) cout<<num<<endl;
    else cout<<"Impossible"<<endl;
    int a=0;
    cin>>a;
    return 0;   
}

```

# 算法的优化

## BFS算法与A*算法：
    BFS是一种“盲目”的搜索技术，过程中并不理会目标在哪里
    A*属于一种“启发式搜索算法”简单而言，A*是BFS+贪心法

    程序如何知道向某个方向走最快？引入曼哈顿距离（两个点在坐标系上的实际距离（先上后下那种）
    从起点开始一圈，附近的点找到其曼哈顿距离，走曼哈顿距离更小的那样一个方向
## A*：
    用一个评估函数f（x）对情况进行评估，得到最好的状态，从这个状态继续搜索，找到最好的目标
    f(x)=g(x)+h(x)
    g(X)表示从初始状态到x的实际代价，不体现x和终点的实际关系
    h(X)表示x到终点的最优路径的评估（启发函数）h（x）决定了算法的优劣,h(x)不能漏掉最优解！

    八数码中,曼哈顿距离就是h(x).就是当前每一个数据到目标每一个数据的曼哈顿距离之和

## 双向广搜：
    BFS增强版
    BFS想象成：在起点丢一块石头激起千层浪直到碰到终点，那么双向广搜就是在起点、终点同时做BFS
        两个波浪在某个位置相遇，就是最优路径了，这样比BFS的空间少很多，更有效
    应用地点：知道起点和终点，并且正向和逆向都能进行搜索

# DFS

## DFS:深度优先搜索

模板：

```c++
这里还有两个普通的深搜模板
深度优先搜索算法框架1
int Search(int k)
　{
　for (i=1;i<=算符种数;i++)
　　if (满足条件)
　　   {
　　　　保存结果
　　　　if (到目的地) 输出解;
　　　           else Search(k+1);
　　　　恢复：保存结果之前的状态{回溯一步}
　 　  }
　}
 深度优先搜索算法框架2
int Search(int k)
　{
　  if  (到目的地) 输出解;
　　　else
　　　　for (i=1;i<=算符种数;i++)
　　　　　if  (满足条件) 
　　　　　　　{
　　　　　　　　保存结果;
　　　                  Search(k+1)
                             恢复：保存结果之前的状态{回溯一步}
　　　　　　　}
　}
 希望各位都能顺利学会DFS，也希望管理大大能通过此篇题解！
```

### 回溯与剪枝

    回溯：递归的时候“看到不对头就撤退”的思想，返回。
    其中，用于减少子节点扩展的函数就叫做剪枝函数
#### 八皇后问题：
    棋盘上放8皇后，使他不同行列对角线
    回溯与剪枝：设已经放好的皇后坐标（i,j）新皇后坐标（r，c）
    则：列不同(j不等于c)对角线不同（若同，则有左上，左下，右上，右下关系综合而言就是不可以|i-r|==|j-c|
法一：学习点同上

```c++
# include<bits/stdc++.h>
using namespace std;
int n,tot=0;
int col[12]={0};
bool check(int c,int r )
{
    for (int i = 0; i < r; i++)
    {
        if(col[i]==c||(abs(col[i]-c)==abs(i-r)))//检查列，对角线是否有其他皇后
            return false;
    }
    return true;
}
void DFS(int r )//一行一行地放皇后，这次是第r行
{
    if(r==n)//所有的皇后都放置好了，返回
    {
        tot++;//统计合法的棋盘个数
        return ;
    }
    for (int c = 0; c < n; c++)//在对应行的某一列放皇后
    {
        if(check(c,r))//检查合法性
        {
            col[r]=c;//在第r行的c列放皇后
            DFS(r+1);//准备在下一行放皇后
        }
    }

}
int main()
{
    int ans[12]={0};
    for(n=0;n<=10;n++)//先打表计算皇后问题
    {
        memset(col,0,sizeof(col));//清空，准备下一个八皇后类型
        tot=0;
        DFS(0);//此处代表第0行
        ans[n]=tot;//打表
    }
    while(cin>>n)
    {
        if(n==0)
        return 0;
        cout<<ans[n]<<endl;
    }

    return 0;
}
```

法2：学习：占位和退位的思想，对角线的表示形式

```c++
#include <iostream>
#include <vector>
using namespace std;
#define MAX_N 100
/*
学习：占位和退位的思想，对角线的表示形式
*/
int a[MAX_N], n, ans = 0;
int b1[MAX_N], b2[MAX_N], b3[MAX_N]; // 分别记录y,x+y,x-y+15是否被占用
/*
b2数组（对角线）：
(左下与右上的线）
b2[x + i] 表示第 x 行和第 i 列的对角线是否被占用。
对于每一个皇后，它的位置是 (x, i)，那么它所在的对角线编号为 x + i。
如果 b2[x + i] 的值为 1，说明在这个对角线上已经有皇后存在。
b3数组（反对角线）：

b3:(左上与右下的线）
b3[x - i + 15] 表示第 x 行和第 i 列的反对角线是否被占用。
对于每一个皇后，它的位置是 (x, i)，那么它所在的反对角线编号为 x - i + 15。
加上常数 15 是为了保证数组的索引不会出现负数。
如果 b3[x - i + 15] 的值为 1，说明在这个反对角线上已经有皇后存在。
*/
void dfs(int x)
{
    if (x > n)
    {
        ans++;
        if (ans <= 3)
        {
            for (int i = 1; i <= n; i++)
            {
                cout << a[i] << " ";
            }
            cout << endl;
        }
        return;
    }
    for (int i = 1; i <= n; i++) // 模拟列的情况
    {
        // b1记录第i排竖排是否被占用
        // b2
        if (b1[i] == 0 && b2[x + i] == 0 && b3[x - i + 15] == 0)
        {
            a[x] = i; // 记录展位的地方
            b1[i] = 1;
            b2[x + i] = 1;
            b3[x - i + 15] = 1; // 占位
            dfs(x + 1);
            b1[i] = 0;
            b2[x + i] = 0;
            b3[x - i + 15] = 0; // 取消占位
        }
    }
}
int main()
{
    cin >> n;
    dfs(1);
    cout << ans;
}```
## IDDFS
    迭代加深搜索：IDDFS
        某些题目，很深很广，DFS陷入递归无法返回，BFS队列空间爆炸
        操作：
            1，先设置搜索深度为1，用DFS搜索到第一层就停止（DFS搜索一个深度为1的搜索树）
            2，没有找到答案，那么就再设定搜索深度为2，用DFS搜索前两层就停止（DFS搜索一个深度为2的搜索树）
            3，继续设定深度为3/4，逐步扩大范围，找到答案，
            过程当中，每一层在广度上采用了BFS的思想，编程实现上则是DFS的
    IDA*：对IDDFS的优化
        IDDFS实际上仍然是一种“盲目”的搜索，只是把范围控制在了可行的空间当中，如果能在IDDFS的过程当中预测当前DFS的状态，不再深入，就可以提高效率，这个预测就是在IDDFS当中加一个估价函数（经过这个函数计算，发现后续无解，则返回）
        简单而言，就是在过程当中利用估价函数进行剪枝操作

eg：从1开始，要进行多少次加减法才能到达n
```c++

# include<bits/stdc++.h>
using namespace std;
int val[1010];
int pos,n;

bool ida(int now,int depth)
{
    if(now>depth)
        return false;//IDDFS大于当前设置的深度
    if(val[pos]<<(depth-now)<n)
        return false;//估价函数，用最快的速率都不能到达n，退出
    if(val[pos]==n)return true;
    pos++;
    for (int i = 0; i < pos; i++)
    {
        val[pos]=val[pos-1]+val[i];//上一个数与前面所有的数相加
        if(ida(now+1,depth)) return true;//
        val[pos]=abs(val[pos-1]-val[i]);//上一个数与前面的所有数相减
        if(ida(now+1,depth))return true;
    }
    pos--;
    return false;
}

int main()
{
    while (cin>>n&&n)
    {
        int depth;
        for (depth =0;;depth++)//每次只DFS到深度depth
        {
            val[pos=0]=1;//初始值是1
            if(ida(0,depth))
                break;
        }
        cout<<depth<<endl;
    }
}
```

例题：单词输出：学习点：1，dr,dc是方向，r，c代表第一个字母'r'的坐标位置;2，两个数组，一个记录数据，一个记录状态

```C++
#include <iostream>
#include <algorithm>
using namespace std;
// P1101单词方阵
char word[] = {'y', 'i', 'z', 'h', 'o', 'n', 'g'};
char mat[103][103];
char ansmat[103][103];
int n;
void dfs(int dr, int dc, int r, int c, int cut);
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            cin >> mat[i][k];
            ansmat[i][k] = 0;
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            if (mat[i][k] == 'y')
            {
                // 这里是起点了哇
                for (int dr = -1; dr <= 1; dr++)
                {
                    for (int dc = -1; dc <= 1; dc++)
                    {
                        if (mat[i + dr][k + dc] == 'i')
                        {
                            dfs(dr, dc, i, k, 0); // 方向，搜索
                        }
                    }
                }
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            if (ansmat[i][k])
            {
                cout << mat[i][k];
            }
            else
            {
                cout << "*";
            }
        }
        cout << endl;
    }
}
// dr,dc是方向，r，c代表第一个字母'r'的坐标位置
void dfs(int dr, int dc, int r, int c, int cut)
{
    if (cut == 7)
    {
        for (int i = 1; i <= 7; i++)
        {
            ansmat[r - dr * i][c - dc * i] = 1; // 标记为保留
        }
    }
    if (r >= 1 && r <= n && c >= 1 && c <= n && mat[r][c] == word[cut])
    {
        dfs(dr, dc, r + dr, c + dc, cut + 1);
    }
    return;
}

```

例题：自然数的拆分：学习点：1，回溯的运用// 回溯，加上拆分的数(回复s开始的值)，使得产生所有可能的拆分2，用一个数组保存当前拆分的数3，加法的问题，逆向思维成减法的问题

```c++
#include <cstdio>
#include <iostream>
#include <cstdlib>
using namespace std;
int a[10001] = {1}, n;
////用于存储拆分 n 的数的序列。初始值为 1，因为 a[0] 是用于开始拆分的初始值。

void search(int, int);
void print(int);
int main()
{
    cin >> n;
    search(n, 1); // 将要拆分的数n传递给s
    return 0;
}
void printff(int t)
{
    for (int i = 1; i <= t - 1; i++) // 输出一种拆分方案  [9934] 0 int

        cout << a[i] << "+";
    // if(a[t]!=t)
    cout << a[t] << endl;
}

void search(int s, int t) // s是要拆分的数值，t是要拆分的位数
{
    int i;
    for (i = a[t - 1]; i <= s; i++)
        if (i < n) // 当前数i要大于等于前一位数，且不超过n
        {
            a[t] = i; // 保存当前拆分的数i
            s -= i;   // s减去数i，s的值将继续拆分
            if (s == 0)
                printff(t); // 当s=0时，拆分结束输出结果
            else
                search(s, t + 1); // 当s>0时，继续递归
            s += i;               // 回溯，加上拆分的数(回复s开始的值)，使得产生所有可能的拆分
        }
}
```

例题3：

```c++
/*
思路：
1，现在所有数字周围先围一圈0，然后按照右、下的方法，将那一圈0改成5
2，遍历矩阵，将0设置成2
3，再次遍历，将3设置成0
//虽然这个代码过不了，但是主要到要在所有的数字外面加一圈0再进行搜索是很好的思想
*/
#include<bits/stdc++.h>
using namespace std;
int n=0;
int mat[35][35];
void dfs(int x,int y);
int main()
{
    cin>>n;
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            cin>>mat[i][k];
        }
    }
    dfs(0,0);
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            if(mat[i][k]==3)
            {
                cout<<0;
            }
            if(mat[i][k]==1)
            {
                cout<<1;
            }
            if(mat[i][k]==0)
            {
                cout<<0;
            }
        } 
        cout<<endl;   
    }
    
}
void dfs(int x,int y)
{
    //向右和向下分别搜索
    if(mat[x][y]==0)
    {
        mat[x][y]=3;
        if(x+1<=n+1&&y<=n+1)
        {
            dfs(x+1,y);
        }
        if(x<=n+1&&y+1<=n+1)
        {
            dfs(x,y+1);
        }
    }
}
```

## 总结BFS，DFS

    设点的数量是V连接点的边的总数是E，那么总复杂度是O（V+E）但是有些V和E本身就是指数级的
    因此搜索的时候多用剪枝、回溯、双向广搜、迭代加深、A*、IDA*等方法去加上你好搜索的次数

    应用场合：
    能用DFS，尽量使用。
    BFS：求解最优解（如迷宫这样的求最短路径）
    DFS：多用于求可行解

# 杂

## P1106删数问题

Tip1：思想：找最高峰，得到最小的数字
Tip2：处理前导0的技巧，删除函数的earse的技术

```c++
int main()
{
    //思路：找高峰期
    int s,i;
    cin>>n>>s;
    while(s)
    {
        for(i=0;n[i]<=n[i+1];)//找到了1个高峰辽
        {
            i++;
        }
        n.erase(i,1);//删除函数，从第i个位置删除1个
        s--;
    }
    while(n[0]=='0'&&n.size()>1)
    {
        //处理前导0，如果长度是1就不能删啦
        n.erase(0,1);
    }
    cout<<n;
}
```

# 搜索技术

    使用的算法：BFS（队列实现）DFS（递归实现）
    两种算法衍生=>A*算法、双向广搜算法、迭代加深搜索、IDA*......
## 暴力搜索常见操作：
    1，找到所有可能的数据并且用数据结构表示出来（也有难度）
    2，剪枝，减少搜索的空间
    3，用某个算法检索这些数据

## 4.1:递归与全排列
    =>需要进行全排列的题目，元素应当小于11个（否则会超时）

## 4.2:子集生成和组合问题：
    用二进制的概念表示子集是否存在最为直观eg:
    a0 a1 a2 ;a0 a1...
    1  1  1   1  1  0...
    每一个子集对应一个二进制数这个二进制数的每一个1对应着这个子集中的某个元素
    也可以推出子集的个数为2^n（表中二进制的总个数是2^n)

```c++
int main()
{
int n;
cin>>n;
print_subset(n);
cin>>n;
}
void print_subset(int n)
{
    for (int i = 0; i < (1<<n); i++)//1左移一位变成（10）即相当于2的一次方，左移n位即相当于2的n次方
    {
        for (int j = 0; j < n; j++)
        {
            if(i&(1<<j))
                cout<<j<<" ";
        }
        cout<<endl;
    }
}
```

# 递推与递归

## 递推思想

    对于一个问题，能确定初始（边界）条件，写出递推式，那么就可以考虑使用递推
    规模很大的递推任务可以使用矩阵加速
    在【过河卒】题目当中，使用递推思路比DFS远远要快

### (类)斐波那契数列

    eg:数楼梯
    设走到第i个台阶的走法是f[i],则f[100]=f[99]+f[98](要走到100首先要到98或者99然后一步)
    =>f[i]=f[i-1]+f[i-2]
    初始条件f[1]=1;f[2]=2;
    ****斐波那契的初始条件是f[1]=f[2]=1******

```python
n=int(input())
f=[0] * 5010
f[1]=1
f[2]=2
for i in range(3,n+1):
  f[i]=f[i-2]+f[i-1]
print(f[n])
```

### 栈

```cpp
// n个小球按顺序一个个入管，
// 一次可以任意个球倒出来，求倒出来的方式：
/*
分析：
    每一个球都可以是最后出管的
    设第k个球是最后出管的，比k早入且早出有k-1
    共h[k-1]种方式，比k晚入早出有n-k,共h[n-k]方式
    则这种情况下有h[k-1]*h[n-k]方式
    所以递推式：
    h(n)=h(0)*h(n-1)+h(1)*h(n-2)+...+h(n-1)*h(0)
    h[0]=h[1]=1

*/
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n, h[20] = {1, 1};
    for (int i = 2; i < n + 1; i++)
    {
        for (int j = 0; j < i; j++)
        {
            h[i] += h[j] * h[i - j - 1];
        }
    }
    cout << h[n];
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;
/*
注意到：
f[i]=f[i/2]+f[(i-1)/2]+...+f[2]+f[1]

*/
int n, t[1010];
int main()
{
    cin >> n;
    t[1] = 1, t[2] = 2, t[3] = 2, t[4] = 4, t[5] = 4, t[6] = 6;
}
int solution(int x)
{
    int ans = 0;
    for (int i = 1; i <= n; i++) // 1~n的递推
    {
        for (int j = 1; j <= i / 2; j++)
        {
            t[i] += t[j];
        }
        t[i]++;//加本身
    }
}
```

## 递归思想

### 例题：数的计算

注意：有时候搜索会超过指定长度，记得使用一个数组将结果保存下来，以后想要使用结果的时候直接查表就可以了

```cpp
#include<bits/stdc++.h>
/*
8后面加上一个元素，可以是4/3/2/1
但要加上其他的数列，怎么处理？=>
加上4/3/2/1的答案即可
原本是8的问题，现在分解成了4个子问题的问题，一直向下分解，直到得到了解为止。直到1，无法再继续分解即可
*/
int f[1010],n;
using namespace std;
int solution_vision2(int x);
int main()
{
    cin>>n;
    memset(f,-1,sizeof(f));//将f中的每一个元素的值都赋值成-1
    f[1]=1;
    int k=solution_vision2(n);
    cout<<k;
}
/*
solution不能通过问题，原因是做了很多的无效功，比如sol(2)会被sol(4)和sol(8)重复计算
所以可以定义一个数组f，当需要问题的答案是，进行查询
*/
int solution_vision2(int x)
{
    int ans=1;
    if(f[x]!=-1)
    {
        return f[x];
    }
    for (int i = 1; i <= x/2; i++)
    {
        ans+=solution_vision2(i);
    }
    return f[x]=ans;//将 ans 赋值给数组 f 的第 x 个元素，并将这个值作为函数的返回值返回。
}
int solution_vision1(int x)
{
    if (x==1)
    {
        return 1;
    }
    int ans=1;//自己本身就是一个解
    for (int i = 1; i <= x/2; i++)
    {
        ans+=solution_vision1(i);
    }
    return ans;
}
```

递推用在字符串处理的问题上：

```cpp
#include <bits/stdc++.h>
using namespace std;

string expend2();
int m;
int main()
{
    cout << expend2();
    cin >> m;
    // cout<<rezip(mima);
}
string expend2()
{
    string mima, x;
    char c;
    int times;
    while (cin >> c) // 持续读完所有的字符
    {
        if (c == '[')
        {
            cin >> times;
            x = expend2();
            while (times--)
            {
                mima += x;
            }
        }
        else if (c == ']')
        {
            return mima;
        }
        else
        {
            mima += c;
        }
    }
    return mima;
}
```

## 递推与递归

很多时候，可以递推的问题也可以用递归，相互转化。
但是，递推要求出递推顺序（多维递推，如【数的计算】），初始条件，这个时候采用递归更好捏#BFS

# 棋盘问题

学习点：1,二维数组表示上下左右方向2,

```c++
#include<bits/stdc++.h>
using namespace std;
int Wx,Wy,num;//表示有Wx行，Wy列;用num统计可走的位置有多少
char room[23][23];
struct node//表示每个节点
{
        int x;
        int y;
};
int dir[4][2]={
{-1,0},//左（左上角的坐标为（0,0）
{0,-1},//上
{1,0},//右
{0,1}};//下
int main()
{
    int x,y, dx,dy;//dx和dy表示起点的坐标
    while(cin>>Wx>>Wy)
    {
        if(Wx==0&&Wy==0)
        {
            break;
        }
        for(y=0;y<Wy;y++)
        {
            for(x=0;x<Wx;x++)
            {
                cin>>room[x][y];
                if(room[x][y]=='@')//是起点呢
                {
                    dx=x;dy=y;
                }
            }
        }
    num=0;
    BFS(dx,dy);
    cout<<num<<endl;
    }
}
bool cheack_in_room(int x,int y)
{
    return x<Wx&&x>=0&&y>=0&&y<Wy;
}
void BFS(int dx,int dy)
{
    num=1;
    queue <node> q;
    node start,next;
    start.x=dx,start.y=dy;
    q.push(start);
    while(!q.empty())
    {
        start=q.front();
        q.pop();
    }
    for (int i = 0; i < 4; i++)//按照左上右下四个方向顺时针逐一搜索
    {
        next.x=start.x+dir[i][0];
        next.y=start.y+dir[i][1];
        if(cheack_in_room(next.x,next.y)&&room[next.x][next.y]=='.')
        {
            room[next.x][next.y]=='#';
            num++;
            q.push(next);
        }
    }    
}
```

# 八皇后问题

## 八数码问题和状态图搜索
### 问题：
        8个数字在3x3的棋盘当中，移动数码使得到达目标位置
        问到达某个指定位置时，要多少步
### 分析：
        BFS，广度搜索
        但会发现需要判重，需要把新状态与9！对比，有9！*9！次检查
### 判重方法：
        康拓展开：
        Cantor()复杂度：n^2
        输入一个排列，返回它的排名，在数组当中将其置为1，从而实现排列
        公式：第X个排序的计算公式如下：
        X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[2]*1+a[0]*0!
        a[i]表示原数的第i位在当前未出现的元素当中排在第几个（0开始）

```c++
#include<bits/stdc++.h>
using namespace std;

const int LEN=362880;
struct node
{
    int state[9];//记录八数码的排列，一个状态
    int distance;//记录到起点的距离
};
int visited[LEN]={0};//原先的状态全为0
int start[9];//开始目标
int goal[9];//结束目标
long int factory[]={1,1,2,6,24,120,720,5040,40320,362880};//康拓展开需要用到的常数
int dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}};
//康托展开
bool Cantor(int str[],int n)
{
    int result=0;
    for (int i = 0; i < n; i++)
    {
        int counted=0;
        for (int j = i+1; j < n; j++)
        {
            if(str[i]>str[j])//当前未出现的元素排在第几个
                ++counted;

        }
        result+=counted*factory[n-i-1];//用数组枚举
    }
    if(!visited[result])//没有被访问过
    {
        visited[result]=1;
        return 1;
    }
    else
        return 0;
    
}
int BFS()
{
    node head;
    memcpy(head.state,start,sizeof(head.state));//复制起点的状态
    head.distance=0;
    queue<node>q;
    Cantor(head.state,9);
    q.push(head);

    while (!q.empty())
    {
        head=q.front();
        if(memcmp(head.state,goal,sizeof(goal))==0)//与目标状态对比
        {
            return head.distance;//到达目标目标，返回局里，结束
        }
        q.pop();
        int z;
        for ( z = 0; z <9; z++)
        {
            if(head.state[z]==0)
                break;
        }
        //转化为二维，左上角是原点(0,0)
        int x=z%3;//横坐标
        int y=z/3;//纵坐标
        for (int i = 0; i < 4; i++)//上下左右最多可能有4个新状态
        {
            //元素0转移后的新坐标
            int newx=x+dir[i][0];
            int newy=y+dir[i][1];
            //转化成1维
            int nz=newx+3*newy;
            if(newx>=0&&newx<3&&newy>=0&&newy<3)
            {
                node newnode;
                memcpy(&newnode,&head,sizeof(struct node));
                swap(newnode.state[z],newnode.state[nz]);//0移动到新的位置
                newnode.distance++;
                if (Cantor(newnode.state,9))
                {
                    q.push(newnode);
                }
                
            }
            
        }
        
    }
    return -1;

}

int main()
{
    for (int i = 0; i < 9; i++)
    {
        cin>>start[i];
    }
    for (int i = 0; i < 9; i++)
    {
        cin>>goal[i];
    }
    int num=BFS();
    if(num!=1) cout<<num<<endl;
    else cout<<"Impossible"<<endl;
    int a=0;
    cin>>a;
    return 0;   
}

```

# 算法的优化

## BFS算法与A*算法：
    BFS是一种“盲目”的搜索技术，过程中并不理会目标在哪里
    A*属于一种“启发式搜索算法”简单而言，A*是BFS+贪心法

    程序如何知道向某个方向走最快？引入曼哈顿距离（两个点在坐标系上的实际距离（先上后下那种）
    从起点开始一圈，附近的点找到其曼哈顿距离，走曼哈顿距离更小的那样一个方向
## A*：
    用一个评估函数f（x）对情况进行评估，得到最好的状态，从这个状态继续搜索，找到最好的目标
    f(x)=g(x)+h(x)
    g(X)表示从初始状态到x的实际代价，不体现x和终点的实际关系
    h(X)表示x到终点的最优路径的评估（启发函数）h（x）决定了算法的优劣,h(x)不能漏掉最优解！

    八数码中,曼哈顿距离就是h(x).就是当前每一个数据到目标每一个数据的曼哈顿距离之和

## 双向广搜：
    BFS增强版
    BFS想象成：在起点丢一块石头激起千层浪直到碰到终点，那么双向广搜就是在起点、终点同时做BFS
        两个波浪在某个位置相遇，就是最优路径了，这样比BFS的空间少很多，更有效
    应用地点：知道起点和终点，并且正向和逆向都能进行搜索

# DFS

## DFS:深度优先搜索

模板：

```c++
这里还有两个普通的深搜模板
深度优先搜索算法框架1
int Search(int k)
　{
　for (i=1;i<=算符种数;i++)
　　if (满足条件)
　　   {
　　　　保存结果
　　　　if (到目的地) 输出解;
　　　           else Search(k+1);
　　　　恢复：保存结果之前的状态{回溯一步}
　 　  }
　}
 深度优先搜索算法框架2
int Search(int k)
　{
　  if  (到目的地) 输出解;
　　　else
　　　　for (i=1;i<=算符种数;i++)
　　　　　if  (满足条件) 
　　　　　　　{
　　　　　　　　保存结果;
　　　                  Search(k+1)
                             恢复：保存结果之前的状态{回溯一步}
　　　　　　　}
　}
 希望各位都能顺利学会DFS，也希望管理大大能通过此篇题解！
```

### 回溯与剪枝

    回溯：递归的时候“看到不对头就撤退”的思想，返回。
    其中，用于减少子节点扩展的函数就叫做剪枝函数
#### 八皇后问题：
    棋盘上放8皇后，使他不同行列对角线
    回溯与剪枝：设已经放好的皇后坐标（i,j）新皇后坐标（r，c）
    则：列不同(j不等于c)对角线不同（若同，则有左上，左下，右上，右下关系综合而言就是不可以|i-r|==|j-c|
法一：学习点同上

```c++
# include<bits/stdc++.h>
using namespace std;
int n,tot=0;
int col[12]={0};
bool check(int c,int r )
{
    for (int i = 0; i < r; i++)
    {
        if(col[i]==c||(abs(col[i]-c)==abs(i-r)))//检查列，对角线是否有其他皇后
            return false;
    }
    return true;
}
void DFS(int r )//一行一行地放皇后，这次是第r行
{
    if(r==n)//所有的皇后都放置好了，返回
    {
        tot++;//统计合法的棋盘个数
        return ;
    }
    for (int c = 0; c < n; c++)//在对应行的某一列放皇后
    {
        if(check(c,r))//检查合法性
        {
            col[r]=c;//在第r行的c列放皇后
            DFS(r+1);//准备在下一行放皇后
        }
    }

}
int main()
{
    int ans[12]={0};
    for(n=0;n<=10;n++)//先打表计算皇后问题
    {
        memset(col,0,sizeof(col));//清空，准备下一个八皇后类型
        tot=0;
        DFS(0);//此处代表第0行
        ans[n]=tot;//打表
    }
    while(cin>>n)
    {
        if(n==0)
        return 0;
        cout<<ans[n]<<endl;
    }

    return 0;
}
```

法2：学习：占位和退位的思想，对角线的表示形式

```c++
#include <iostream>
#include <vector>
using namespace std;
#define MAX_N 100
/*
学习：占位和退位的思想，对角线的表示形式
*/
int a[MAX_N], n, ans = 0;
int b1[MAX_N], b2[MAX_N], b3[MAX_N]; // 分别记录y,x+y,x-y+15是否被占用
/*
b2数组（对角线）：
(左下与右上的线）
b2[x + i] 表示第 x 行和第 i 列的对角线是否被占用。
对于每一个皇后，它的位置是 (x, i)，那么它所在的对角线编号为 x + i。
如果 b2[x + i] 的值为 1，说明在这个对角线上已经有皇后存在。
b3数组（反对角线）：

b3:(左上与右下的线）
b3[x - i + 15] 表示第 x 行和第 i 列的反对角线是否被占用。
对于每一个皇后，它的位置是 (x, i)，那么它所在的反对角线编号为 x - i + 15。
加上常数 15 是为了保证数组的索引不会出现负数。
如果 b3[x - i + 15] 的值为 1，说明在这个反对角线上已经有皇后存在。
*/
void dfs(int x)
{
    if (x > n)
    {
        ans++;
        if (ans <= 3)
        {
            for (int i = 1; i <= n; i++)
            {
                cout << a[i] << " ";
            }
            cout << endl;
        }
        return;
    }
    for (int i = 1; i <= n; i++) // 模拟列的情况
    {
        // b1记录第i排竖排是否被占用
        // b2
        if (b1[i] == 0 && b2[x + i] == 0 && b3[x - i + 15] == 0)
        {
            a[x] = i; // 记录展位的地方
            b1[i] = 1;
            b2[x + i] = 1;
            b3[x - i + 15] = 1; // 占位
            dfs(x + 1);
            b1[i] = 0;
            b2[x + i] = 0;
            b3[x - i + 15] = 0; // 取消占位
        }
    }
}
int main()
{
    cin >> n;
    dfs(1);
    cout << ans;
}```
## IDDFS
    迭代加深搜索：IDDFS
        某些题目，很深很广，DFS陷入递归无法返回，BFS队列空间爆炸
        操作：
            1，先设置搜索深度为1，用DFS搜索到第一层就停止（DFS搜索一个深度为1的搜索树）
            2，没有找到答案，那么就再设定搜索深度为2，用DFS搜索前两层就停止（DFS搜索一个深度为2的搜索树）
            3，继续设定深度为3/4，逐步扩大范围，找到答案，
            过程当中，每一层在广度上采用了BFS的思想，编程实现上则是DFS的
    IDA*：对IDDFS的优化
        IDDFS实际上仍然是一种“盲目”的搜索，只是把范围控制在了可行的空间当中，如果能在IDDFS的过程当中预测当前DFS的状态，不再深入，就可以提高效率，这个预测就是在IDDFS当中加一个估价函数（经过这个函数计算，发现后续无解，则返回）
        简单而言，就是在过程当中利用估价函数进行剪枝操作

eg：从1开始，要进行多少次加减法才能到达n
```c++

# include<bits/stdc++.h>
using namespace std;
int val[1010];
int pos,n;

bool ida(int now,int depth)
{
    if(now>depth)
        return false;//IDDFS大于当前设置的深度
    if(val[pos]<<(depth-now)<n)
        return false;//估价函数，用最快的速率都不能到达n，退出
    if(val[pos]==n)return true;
    pos++;
    for (int i = 0; i < pos; i++)
    {
        val[pos]=val[pos-1]+val[i];//上一个数与前面所有的数相加
        if(ida(now+1,depth)) return true;//
        val[pos]=abs(val[pos-1]-val[i]);//上一个数与前面的所有数相减
        if(ida(now+1,depth))return true;
    }
    pos--;
    return false;
}

int main()
{
    while (cin>>n&&n)
    {
        int depth;
        for (depth =0;;depth++)//每次只DFS到深度depth
        {
            val[pos=0]=1;//初始值是1
            if(ida(0,depth))
                break;
        }
        cout<<depth<<endl;
    }
}
```

例题：单词输出：学习点：1，dr,dc是方向，r，c代表第一个字母'r'的坐标位置;2，两个数组，一个记录数据，一个记录状态

```C++
#include <iostream>
#include <algorithm>
using namespace std;
// P1101单词方阵
char word[] = {'y', 'i', 'z', 'h', 'o', 'n', 'g'};
char mat[103][103];
char ansmat[103][103];
int n;
void dfs(int dr, int dc, int r, int c, int cut);
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            cin >> mat[i][k];
            ansmat[i][k] = 0;
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            if (mat[i][k] == 'y')
            {
                // 这里是起点了哇
                for (int dr = -1; dr <= 1; dr++)
                {
                    for (int dc = -1; dc <= 1; dc++)
                    {
                        if (mat[i + dr][k + dc] == 'i')
                        {
                            dfs(dr, dc, i, k, 0); // 方向，搜索
                        }
                    }
                }
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            if (ansmat[i][k])
            {
                cout << mat[i][k];
            }
            else
            {
                cout << "*";
            }
        }
        cout << endl;
    }
}
// dr,dc是方向，r，c代表第一个字母'r'的坐标位置
void dfs(int dr, int dc, int r, int c, int cut)
{
    if (cut == 7)
    {
        for (int i = 1; i <= 7; i++)
        {
            ansmat[r - dr * i][c - dc * i] = 1; // 标记为保留
        }
    }
    if (r >= 1 && r <= n && c >= 1 && c <= n && mat[r][c] == word[cut])
    {
        dfs(dr, dc, r + dr, c + dc, cut + 1);
    }
    return;
}

```

例题：自然数的拆分：学习点：1，回溯的运用// 回溯，加上拆分的数(回复s开始的值)，使得产生所有可能的拆分2，用一个数组保存当前拆分的数3，加法的问题，逆向思维成减法的问题

```c++
#include <cstdio>
#include <iostream>
#include <cstdlib>
using namespace std;
int a[10001] = {1}, n;
////用于存储拆分 n 的数的序列。初始值为 1，因为 a[0] 是用于开始拆分的初始值。

void search(int, int);
void print(int);
int main()
{
    cin >> n;
    search(n, 1); // 将要拆分的数n传递给s
    return 0;
}
void printff(int t)
{
    for (int i = 1; i <= t - 1; i++) // 输出一种拆分方案  [9934] 0 int

        cout << a[i] << "+";
    // if(a[t]!=t)
    cout << a[t] << endl;
}

void search(int s, int t) // s是要拆分的数值，t是要拆分的位数
{
    int i;
    for (i = a[t - 1]; i <= s; i++)
        if (i < n) // 当前数i要大于等于前一位数，且不超过n
        {
            a[t] = i; // 保存当前拆分的数i
            s -= i;   // s减去数i，s的值将继续拆分
            if (s == 0)
                printff(t); // 当s=0时，拆分结束输出结果
            else
                search(s, t + 1); // 当s>0时，继续递归
            s += i;               // 回溯，加上拆分的数(回复s开始的值)，使得产生所有可能的拆分
        }
}
```

例题3：

```c++
/*
思路：
1，现在所有数字周围先围一圈0，然后按照右、下的方法，将那一圈0改成5
2，遍历矩阵，将0设置成2
3，再次遍历，将3设置成0
//虽然这个代码过不了，但是主要到要在所有的数字外面加一圈0再进行搜索是很好的思想
*/
#include<bits/stdc++.h>
using namespace std;
int n=0;
int mat[35][35];
void dfs(int x,int y);
int main()
{
    cin>>n;
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            cin>>mat[i][k];
        }
    }
    dfs(0,0);
    for (int i = 1; i <= n; i++)
    {
        for (int k = 1; k <= n; k++)
        {
            if(mat[i][k]==3)
            {
                cout<<0;
            }
            if(mat[i][k]==1)
            {
                cout<<1;
            }
            if(mat[i][k]==0)
            {
                cout<<0;
            }
        } 
        cout<<endl;   
    }
    
}
void dfs(int x,int y)
{
    //向右和向下分别搜索
    if(mat[x][y]==0)
    {
        mat[x][y]=3;
        if(x+1<=n+1&&y<=n+1)
        {
            dfs(x+1,y);
        }
        if(x<=n+1&&y+1<=n+1)
        {
            dfs(x,y+1);
        }
    }
}
```

## 总结BFS，DFS

    设点的数量是V连接点的边的总数是E，那么总复杂度是O（V+E）但是有些V和E本身就是指数级的
    因此搜索的时候多用剪枝、回溯、双向广搜、迭代加深、A*、IDA*等方法去加上你好搜索的次数

    应用场合：
    能用DFS，尽量使用。
    BFS：求解最优解（如迷宫这样的求最短路径）
    DFS：多用于求可行解
