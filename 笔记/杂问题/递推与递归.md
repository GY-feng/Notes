# 递推与递归：
## 递推思想：
    对于一个问题，能确定初始（边界）条件，写出递推式，那么就可以考虑使用递推
    规模很大的递推任务可以使用矩阵加速
    在【过河卒】题目当中，使用递推思路比DFS远远要快
### (类)斐波那契数列：
    eg:数楼梯
    设走到第i个台阶的走法是f[i],则f[100]=f[99]+f[98](要走到100首先要到98或者99然后一步)
    =>f[i]=f[i-1]+f[i-2]
    初始条件f[1]=1;f[2]=2;
    ****斐波那契的初始条件是f[1]=f[2]=1******
```python
n=int(input())
f=[0] * 5010
f[1]=1
f[2]=2
for i in range(3,n+1):
  f[i]=f[i-2]+f[i-1]
print(f[n])
```
### 栈
```cpp
// n个小球按顺序一个个入管，
// 一次可以任意个球倒出来，求倒出来的方式：
/*
分析：
    每一个球都可以是最后出管的
    设第k个球是最后出管的，比k早入且早出有k-1
    共h[k-1]种方式，比k晚入早出有n-k,共h[n-k]方式
    则这种情况下有h[k-1]*h[n-k]方式
    所以递推式：
    h(n)=h(0)*h(n-1)+h(1)*h(n-2)+...+h(n-1)*h(0)
    h[0]=h[1]=1

*/
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n, h[20] = {1, 1};
    for (int i = 2; i < n + 1; i++)
    {
        for (int j = 0; j < i; j++)
        {
            h[i] += h[j] * h[i - j - 1];
        }
    }
    cout << h[n];
}
```
